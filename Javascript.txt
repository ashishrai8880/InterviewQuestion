1.	Closure  

closure is created when a child function keep the environment of the parent scope even after the parent function has already executed 

function foo() {
	let b = 1;
	function inner() {
		return b;
	}
	return inner;
}
let get_func_inner = foo();

console.log(get_func_inner()); //1
console.log(get_func_inner()); //1
console.log(get_func_inner());  //1


2.	Call , Apply and Bind() method In JS

Ans.  JavaScript provides three methods for manipulating the this keyword in functions: call(), apply(), and bind(). These methods allow you to change the context of the this keyword, which can be useful for controlling the behaviour of functions. 

	1. call(); (Call Method)
The call() method allows you to call a function with a specified this value and arguments provided individually. The first argument to call() sets the this value for the function being called, and the remaining arguments are passed to the function as arguments.

let userDetails = {
    name : 'Ashish Rai',
    age : 22 ,
    printDetails :function (){
        console.log(this.name);
    }
}

userDetails.printDetails();

let userDetails2 = {
    name : 'Baniya',
    age : 23 ,
}

userDetails.printDetails.call(userDetails2);

#Real Life Example
const fs = require('fs');

function logData() {
  console.log(this.filename);
}

const file = { filename: 'data.txt' };

// Using call to set 'this' context for logData function
fs.readFile('data.txt', 'utf8', function (err, data) {
  if (err) throw err;
  logData.call(file);  // Output: data.txt
});


userDetails.printDetails.apply(userDetails2 ,[ ‘New Name’ , ‘Another name’]);

const store = userDetails.printDetails.bind(userDetails2);\
store();

3.	Hoisting : 
	In JavaScript, Hoisting is the default behavior of moving all the declarations at the top of the scope before code execution. Basically, it gives us an advantage that no matter where functions and variables are declared, they are moved to the top of their scope regardless of whether their scope is global or local. 
	It allows us to call functions before even writing them in our code. 
Note: JavaScript only hoists declarations, not initializations.

fun();  //calling before declaration
function fun() {
  
  let name = 'Mukul Latiyan';
  console.log(name);
}

Isme variable and function declration top me ho jaata hai lekin initialization nhi hota . Or ye bas var k sath hota hai , let const k sath nhi hota .

// =================================================================================================================================================================
============================================================  Temporal Dead Zone ===================================================================================
Temporal Dead Zone in JavaScript

The Temporal Dead Zone refers to the period between the entering of a scope and the actual declaration of a variable using let or const. During this period, 
the variable is in an "uninitialized" state and accessing it will result in a ReferenceError.

The TDZ starts from the beginning of the block until the variable is declared.
Variables declared with let and const are hoisted but not initialized.
Accessing the variable in the TDZ results in a ReferenceError.
var declarations do not have a TDZ and are initialized as undefined.

Understanding Variable Hoisting
To grasp TDZ, it’s important to understand hoisting. Hoisting is JavaScript's behaviour of moving variable and function declarations to the top of their containing scope during compilation.

var declarations are hoisted and initialized with undefined.
let and const declarations are hoisted but not initialized, leading to the TDZ.
Hoisting with var

console.log(a); // undefined
var a = 5;

Output
undefined
Here, a is hoisted to the top of its scope and initialized with undefined, so accessing it before the declaration doesn’t throw an error.

Temporal Dead Zone with let

console.log(b); // ReferenceError: Cannot access 'b' before initialization
let b = 10;
In this case, b is hoisted but not initialized, so accessing it before the declaration results in a ReferenceError.

Examples to Illustrate Temporal Dead Zone
1. Accessing let and const Before Declaration

function gfg() {
    console.log(x); // ReferenceError
    let x = 3;
}
gfg();

2. Block Scope and TDZ

{
    console.log(y); // ReferenceError
    const y = 7;
}

3. Variables Declared After a Condition

if (true) {
    console.log(z); // ReferenceError
    let z = 9;
}

4. No Temporal Dead Zone with var
{
    console.log(a); // undefined
    var a = 5;
}
Understanding the Flow of TDZ
The Temporal Dead Zone works in the following manner

Variable is declared with let or const: When the variable is hoisted at the top of its current scope but they are not initialized.
Entering TDZ: From the hoisting till the variable initialization it will show the reference error if tried to access.
Variable initialization: When the value is assigned to the variable from that point of time they exits no longer in the TDZ.
Accessing the variable: The variables can be accessed normally after the initialization without any erros.

Why Does Temporal Dead Zone Exist?
In ES6 (ECMAScript 2015) the concept of the Temporal Dead was introduced to prevent the issues which was occurring during the variable hoisting.
When the TDZ concept was not introduced at that time the variables declared with var was automatically set to undefined which was causing the bugs or the issues.
To avoid such problems, Temporal Dead Zone ensures that only let and const variables are only accessible after being initialized.

==================================================================================================================================================================================================================================================================================================================================

4. What is first class function ?
Ans .  A programming language is said to have First-class functions if functions in that language are treated like other variables. So the functions can be assigned to any other variable or passed as an argument or can be returned by another function. JavaScript treats function as a first-class citizen.

const Geek = (a, b) => {
    return (a + " " + b);
}

5. What is Nodejs 
Ans . Node.js is a virtual machine that uses JavaScript as its scripting language and runs Chrome’s V8 JavaScript engine. Basically, Node.js is based on an event-driven architecture where I/O runs asynchronously making it lightweight and efficient .

6. What is Promise ?
Ans . In JavaScript, a Promise is an object that will produce a single value some time in the future. If the promise is successful, it will produce a resolved value, but if something goes wrong then it will produce a reason why the promise failed. The possible outcomes here are similar to that of promises in real life.

JavaScript promises can be in one of three possible states. These states indicate the progress of the promise. They are:

pending: This is the default state of a defined promise
fulfilled:  This is the state of a successful promise
rejected: This is the state of a failed promise

Example : const promise = new Promise((resolve, reject) => {
  const num = Math.random();
  if (num >= 0.5) {
    resolve("Promise is fulfilled!");
  } else {
    reject("Promise failed!");
  }
});

7. What is fork in node JS?
Ans : A fork in general is used to spawn child processes. In node it is used to create a new instance of v8 engine to run multiple workers to execute the code

8. What is callback in NodeJs ?
Ans : Node. js callbacks are a special type of function passed as an argument to another function. They're called when the function that contains
the callback as an argument completes its execution, and allows the code in the callback to run in the meantime. Callbacks help us make 
asynchronous calls


9. What is deep copy and shallow copy ?
Ans : A shallow copy occurs when you copy the reference of an object to a new variable. In this process, only the
top-level properties are copied, while nested objects or arrays still reference the original memory location. This 
means that if you change the nested properties in one object, those changes will reflect in the other because they 
share the same memory reference.

let employee = {
    eid: "E102",
    ename: "Jack",
    eaddress: "New York",
    salary: 50000
}

console.log("Employee=> ", employee);
let newEmployee = employee;    // Shallow copy
console.log("New Employee=> ", newEmployee);

console.log("---------After modification----------");
newEmployee.ename = "Beck";
console.log("Employee=> ", employee);
console.log("New Employee=> ", newEmployee);


Deep Copy
A deep copy, on the other hand, creates a completely independent copy of the object, including all nested objects or arrays. This ensures that changes made to one object do not affect the other. Each object is stored in a separate memory location, making them entirely independent.
