1.	Closure  

closure is created when a child function keep the environment of the parent scope even after the parent function has already executed 

function foo() {
	let b = 1;
	function inner() {
		return b;
	}
	return inner;
}
let get_func_inner = foo();

console.log(get_func_inner()); //1
console.log(get_func_inner()); //1
console.log(get_func_inner());  //1


2.	Call , Apply and Bind() method In JS

Ans.  JavaScript provides three methods for manipulating the this keyword in functions: call(), apply(), and bind(). These methods allow you to change the context of the this keyword, which can be useful for controlling the behaviour of functions. 

	1. call(); (Call Method)
The call() method allows you to call a function with a specified this value and arguments provided individually. The first argument to call() sets the this value for the function being called, and the remaining arguments are passed to the function as arguments.

let userDetails = {
    name : 'Ashish Rai',
    age : 22 ,
    printDetails :function (){
        console.log(this.name);
    }
}

userDetails.printDetails();

let userDetails2 = {
    name : 'Baniya',
    age : 23 ,
}

userDetails.printDetails.call(userDetails2);

#Real Life Example
const fs = require('fs');

function logData() {
  console.log(this.filename);
}

const file = { filename: 'data.txt' };

// Using call to set 'this' context for logData function
fs.readFile('data.txt', 'utf8', function (err, data) {
  if (err) throw err;
  logData.call(file);  // Output: data.txt
});


userDetails.printDetails.apply(userDetails2 ,[ ‚ÄòNew Name‚Äô , ‚ÄòAnother name‚Äô]);

const store = userDetails.printDetails.bind(userDetails2);\
store();

3.	Hoisting : 
ÔÉ∞	In JavaScript, Hoisting is the default behavior of moving all the declarations at the top of the scope before code execution. Basically, it gives us an advantage that no matter where functions and variables are declared, they are moved to the top of their scope regardless of whether their scope is global or local. 
ÔÉ∞	It allows us to call functions before even writing them in our code. 
Note: JavaScript only hoists declarations, not initializations.

fun();  //calling before declaration
function fun() {
  
  let name = 'Mukul Latiyan';
  console.log(name);
}

Isme variable and function declration top me ho jaata hai lekin initialization nhi hota . Or ye bas var k sath hota hai , let const k sath nhi hota .

Example of hoisting . 

1. console.log(a);
var a = 10;

## Output
undefined


2. var a = 10;
console.log(a);

## Output
10

3. console.log(a);
var a;
a = 5;

## Output
undefined

4. var a = 1;
function test() {
  console.log(a);
  var a = 2;
}
test();

## Output
undefined

5. var a = 1;
function test() {
  console.log(a);
}
test();

## Output
1

Key Interview Rules to Remember

‚úÖ var ‚Üí hoisted + initialized as undefined
‚úÖ let / const ‚Üí hoisted but TDZ applies
‚úÖ Function declarations ‚Üí fully hoisted
‚ùå Function expressions ‚Üí behave like variables
‚ùå Classes ‚Üí hoisted but not accessible before declaration


// =================================================================================================================================================================
============================================================  Temporal Dead Zone ===================================================================================
What is Temporal Dead Zone (TDZ) in JavaScript?

Temporal Dead Zone (TDZ) is the time between:
- when a variable is declared
- and when it is initialized

During this time, you cannot use the variable.
TDZ applies to let and const, not var.

Simple Definition (Interview-friendly)
Temporal Dead Zone is the period where a let or const variable exists but cannot be accessed until it is initialized.
If you try to access it ‚Üí ‚ùå ReferenceError

The TDZ starts from the beginning of the block until the variable is declared.
Variables declared with let and const are hoisted but not initialized.
Accessing the variable in the TDZ results in a ReferenceError.
var declarations do not have a TDZ and are initialized as undefined.

Understanding Variable Hoisting
To grasp TDZ, it‚Äôs important to understand hoisting. Hoisting is JavaScript's behaviour of moving variable and function declarations to the top of their containing scope during compilation.

var declarations are hoisted and initialized with undefined.
let and const declarations are hoisted but not initialized, leading to the TDZ.
Hoisting with var

console.log(a); // undefined
var a = 5;

Output
undefined
Here, a is hoisted to the top of its scope and initialized with undefined, so accessing it before the declaration doesn‚Äôt throw an error.

Temporal Dead Zone with let

console.log(b); // ReferenceError: Cannot access 'b' before initialization
let b = 10;
In this case, b is hoisted but not initialized, so accessing it before the declaration results in a ReferenceError.

Examples to Illustrate Temporal Dead Zone
1. Accessing let and const Before Declaration

function gfg() {
    console.log(x); // ReferenceError
    let x = 3;
}
gfg();

2. Block Scope and TDZ

{
    console.log(y); // ReferenceError
    const y = 7;
}

3. Variables Declared After a Condition

if (true) {
    console.log(z); // ReferenceError
    let z = 9;
}

4. No Temporal Dead Zone with var
{
    console.log(a); // undefined
    var a = 5;
}
Understanding the Flow of TDZ
The Temporal Dead Zone works in the following manner

Variable is declared with let or const: When the variable is hoisted at the top of its current scope but they are not initialized.
Entering TDZ: From the hoisting till the variable initialization it will show the reference error if tried to access.
Variable initialization: When the value is assigned to the variable from that point of time they exits no longer in the TDZ.
Accessing the variable: The variables can be accessed normally after the initialization without any erros.

Why Does Temporal Dead Zone Exist?
In ES6 (ECMAScript 2015) the concept of the Temporal Dead was introduced to prevent the issues which was occurring during the variable hoisting.
When the TDZ concept was not introduced at that time the variables declared with var was automatically set to undefined which was causing the bugs or the issues.
To avoid such problems, Temporal Dead Zone ensures that only let and const variables are only accessible after being initialized.

Interview ready made examples 
1. console.log(a); // ‚ùå ReferenceError
let a = 10;

a is known to JavaScript
but not initialized yet
so it is in TDZ

Timeline Visualization
{
  // TDZ starts
  console.log(x); // ‚ùå ReferenceError

  let x = 5; // TDZ ends
  console.log(x); // ‚úÖ 5
}

Key Difference
Keyword		Hoisted		TDZ
var			Yes			‚ùå No
let			Yes			‚úÖ Yes
const		Yes			‚úÖ Yes

üîë let and const are hoisted but not initialized

Why Does TDZ Exist?
Interview answer:
TDZ helps catch bugs by preventing access to variables before they are properly declared.

2Ô∏è‚É£ Does TDZ apply to var?
Answer:
No. TDZ only applies to let and const. var variables are initialized with undefined.

3Ô∏è‚É£ Are let and const hoisted?
Answer:
Yes, they are hoisted but not initialized. That‚Äôs why accessing them before declaration causes TDZ.

4Ô∏è‚É£ What error occurs in TDZ?
Answer:
ReferenceError

5Ô∏è‚É£ When does TDZ start and end?
Answer:
Starts at the beginning of the block
Ends when the variable is declared and initialized

6Ô∏è‚É£ Does TDZ exist inside functions and blocks?
Answer:
Yes. TDZ is block-scoped, so it applies inside { } blocks and functions.

7Ô∏è‚É£ Example question: What is the output?
{
  console.log(a);
  let a = 10;
}
Answer:
‚ùå ReferenceError (because a is in TDZ)

8Ô∏è‚É£ Why doesn‚Äôt this cause an error?
let a = 10;
console.log(a);
Answer:
Because a is accessed after initialization, so TDZ is over.

9Ô∏è‚É£ Is this TDZ?
let a;
console.log(a);
Answer:
‚ùå No TDZ error
a is already initialized with undefined

üîü Does const behave differently from let in TDZ?
Answer:
No. Both have TDZ.
But const must be initialized immediately.
const x; // ‚ùå SyntaxError

üîü
console.log(a);
let a = 10;

Output:
ReferenceError
Why: let is hoisted but not initialized (TDZ).


üîü
let a = 10;
{
  console.log(a);
}

Output:
10

üîü
const a = 10;
a = 20;
console.log(a);

Output:
TypeError

üîπ 3. Function Declarations vs Function Expressions

üîü
hello();
function hello() {
  console.log("Hello");
}

Output:
Hello
Why: Function declarations are fully hoisted.

üîü
hello();

var hello = function () {
  console.log("Hello");
};

Output:
TypeError
Why: TypeError: hello is not a function

üîü
console.log(test);
function test() {}

Output:
ReferenceError
Why: let is hoisted but not initialized (TDZ).

üîü
console.log(a);
let a = 10;

Output:
∆í test() {}

üîü
console.log(test);
var test = function () {};

Output:
undefined

üîπ 4. Hoisting Inside Functions

üîü
function foo() {
  console.log(a);
  a = 10;
}
foo();

Output:
ReferenceError
Why: a is not declared.

üîü
function foo() {
  console.log(a);
  var a = 10;
}
foo();

Output:
undefined

üîü
var a = 5;
(function () {
  console.log(a);
  var a = 10;
})();

Output:
undefined

üîπ 5. Class Hoisting

üîü
const obj = new MyClass();
class MyClass {}

Output:
ReferenceError
Why: Classes are hoisted but in TDZ (like let).

üîπ 6. Mixed Hoisting Tricky Questions

üîü
var x = 10;
function test() {
  console.log(x);
  var x = 20;
}
test();

Output:
undefined

üîü
function test() {
  console.log(x);
}
test();
var x = 5;

Output:
undefined

üîü
console.log(typeof a);
var a = 10;

Output:
undefined


============================================================================================================================
============================================================================================================================
 Execution Context In Javascript

In JavaScript, an execution context is basically the environment where your code is evaluated and run. It determines what 
variables, functions, and objects are accessible at any point in the code.

Every execution context has three main parts:
1. Variable Environment
Stores variables and function declarations
Handles hoisting
Keeps track of let, const, var, and functions

2. Scope Chain
Determines how JavaScript looks up variables
If a variable isn‚Äôt found in the current context, JS looks in the outer context

3. this Keyword
The value of this depends on how the function is called
Not where it‚Äôs written

**************üîπ Types of Execution Contexts
1Ô∏è‚É£ Global Execution Context (GEC)

Created when the JS file first runs
Only one per program
Creates:
	Global object (window in browsers)
	this ‚Üí global object

var x = 10;
console.log(this.x); // 10 (in browser)

2Ô∏è‚É£ Function Execution Context (FEC)
Created every time a function is called
Each function call gets its own context

function greet() {
  let name = "Alex";
  console.log(name);
}
greet(); // creates a new execution context

3Ô∏è‚É£ Eval Execution Context (rare & discouraged)
Created when eval() is used
Avoided due to performance and security issues

****************************** üîπ Phases of Execution Context ************************

Each execution context is created in two phases:

üß± 1. Creation Phase
Memory is allocated
Variables are set to undefined
Function declarations are stored fully
this is defined

console.log(a); // undefined
var a = 5;

‚ñ∂Ô∏è 2. Execution Phase
Code is executed line by line
Variables get assigned real values

a = 5;
console.log(a); // 5

***************************üîπ Execution Context & Call Stack

JavaScript uses a Call Stack to manage execution contexts:
Global Execution Context is pushed first
Function contexts are pushed when called
Contexts are popped when functions return

function first() {
  second();
}
function second() {
  console.log("Hello");
}
first();

üìå Call Stack Flow
Global
‚Üí first()
‚Üí second()
‚Üí pop second()
‚Üí pop first()

*********************************üî∞ Basic Interview Questions
4Ô∏è‚É£ What happens during the creation phase of an execution context?
Answer:
Memory is allocated
Variables are set to undefined
Functions are hoisted completely
this keyword is defined

5Ô∏è‚É£ What happens during the execution phase?
Answer:
JavaScript executes code line by line and assigns actual values to variables.

6Ô∏è‚É£ What is hoisting and how is it related to execution context?
Answer:
Hoisting is JavaScript‚Äôs behavior of moving variable and function declarations to the top during the creation phase of an execution context.

7Ô∏è‚É£ What is the scope chain?
Answer:
The scope chain is used to resolve variables. JavaScript first looks in the current execution context, then in the outer context, and finally in the global context.

8Ô∏è‚É£ What is the relationship between execution context and call stack?
Answer:
JavaScript uses the call stack to manage execution contexts. Each time a function is called, a new execution context is pushed onto the stack and popped after execution.

9Ô∏è‚É£ How many execution contexts are created for a function?
Answer:
A new execution context is created every time the function is called, even if it‚Äôs the same function.

1Ô∏è‚É£3Ô∏è‚É£ What is the difference between execution context and scope?
Answer:
Execution context is created when code runs
Scope defines where variables are accessible
Scope exists before execution, execution context exists during execution.

1Ô∏è‚É£4Ô∏è‚É£ Is execution context synchronous or asynchronous?
Answer:
Execution context itself is synchronous.
Asynchronous operations are handled by Web APIs and the Event Loop, not by execution contexts directly.

1Ô∏è‚É£5Ô∏è‚É£ Does arrow function have its own execution context?
Answer:
Arrow functions create an execution context but do not have their own this. They inherit this from the parent scope.

1Ô∏è‚É£6Ô∏è‚É£ Can multiple global execution contexts exist?
Answer:
‚ùå No. Only one global execution context exists per JavaScript program.

üîπ What is Eval Execution Context?
An Eval Execution Context is a special execution context that is created when JavaScript runs code written inside eval().

üëâ In simple words:
When JavaScript sees eval("some code"), it creates a new execution context to run that code.

üîπ What is eval()?
eval() is a JavaScript function that takes a string and executes it as JavaScript code.
eval("let x = 10; console.log(x);");
Output:
10

üîπ Why Eval Execution Context Exists
JavaScript needs: memory , scope , this value
to run any code, even code written as a string.

So when eval() runs:
‚û°Ô∏è JavaScript creates an Eval Execution Context for that code.

==================================================================================================================================================================================================================================================================================================================================

4. What is first class function ?
Ans .  A programming language is said to have First-class functions if functions in that language are treated like other variables. So the functions can be assigned to any other variable or passed as an argument or can be returned by another function. JavaScript treats function as a first-class citizen.

const Geek = (a, b) => {
    return (a + " " + b);
}

5. What is Nodejs 
Ans . Node.js is a virtual machine that uses JavaScript as its scripting language and runs Chrome‚Äôs V8 JavaScript engine. Basically, Node.js is based on an event-driven architecture where I/O runs asynchronously making it lightweight and efficient .

6. What is Promise ?
Ans . In JavaScript, a Promise is an object that will produce a single value some time in the future. If the promise is successful, it will produce a resolved value, but if something goes wrong then it will produce a reason why the promise failed. The possible outcomes here are similar to that of promises in real life.

JavaScript promises can be in one of three possible states. These states indicate the progress of the promise. They are:

pending: This is the default state of a defined promise
fulfilled:  This is the state of a successful promise
rejected: This is the state of a failed promise

Example : const promise = new Promise((resolve, reject) => {
  const num = Math.random();
  if (num >= 0.5) {
    resolve("Promise is fulfilled!");
  } else {
    reject("Promise failed!");
  }
});

7. What is fork in node JS?
Ans : A fork in general is used to spawn child processes. In node it is used to create a new instance of v8 engine to run multiple workers to execute the code

8. What is callback in NodeJs ?
Ans : Node. js callbacks are a special type of function passed as an argument to another function. They're called when the function that contains
the callback as an argument completes its execution, and allows the code in the callback to run in the meantime. Callbacks help us make 
asynchronous calls


9. What is deep copy and shallow copy ?
Ans : A shallow copy occurs when you copy the reference of an object to a new variable. In this process, only the
top-level properties are copied, while nested objects or arrays still reference the original memory location. This 
means that if you change the nested properties in one object, those changes will reflect in the other because they 
share the same memory reference.

let employee = {
    eid: "E102",
    ename: "Jack",
    eaddress: "New York",
    salary: 50000
}

console.log("Employee=> ", employee);
let newEmployee = employee;    // Shallow copy
console.log("New Employee=> ", newEmployee);

console.log("---------After modification----------");
newEmployee.ename = "Beck";
console.log("Employee=> ", employee);
console.log("New Employee=> ", newEmployee);


Deep Copy
A deep copy, on the other hand, creates a completely independent copy of the object, including all nested objects or arrays. This ensures that changes made to one object do not affect the other. Each object is stored in a separate memory location, making them entirely independent.


======================================================= Event Loop In Browser Perspective =========================================================================

console.log("A")
func(){
	console.log("fun");
}
func()
console.log("B")

- Whatever piece of javascript code we write , first there will be Global Execution Context(GEC) created in callstack . Callstack is basically a place where code actually 
executes . Whatever inside callstack , it immediately executes . In GEC , our program executes line by line . Entire piece of code of program exists in GEC . 
So from line 1 , it executes first console , then there will be func() call in callstack on top of it , it will executes and then second console . 

There are some time taking process which can require resource like network request , i/o operation , timers . 
setTimeout , console , fetch , DOM , localStorage etc -> these are not javascript things , In web side , these are superpower provided by browser , these are not directly related to 
javascript . we can use these using window.console , window.fetch also . These all things comes under global variable called 'window' . 

There are WebAPIs which is responsible to executes these code in web side . All these things are available under WebAPIs . 


console.log("A")

setTimeout( ()=>{
	console.log('timer')
} , 5000 )

console.log("B")


Initial execution will be same , first there will be GEC created in callstack , then first line of console printed . And then there is setTimeout , so it will 
send to WebAPIs , and then it will print last console . 
After completion of 5 seconds in WebAPI , now the code is ready to executes . But wait wait , how the callback function entered into callstack , who will take that 
function into callstack . Because we know everything which executes is under callstack .

Here comes in picture of Event Loop . Now event loop will take that function callback inside callstack . But wait again , does event loop direcly takes from 
WebAPIs . No . There is one more middle man comes in between which is Callback Queue . 

Callback Queue -> It basically stores all the callback which is coming from WebAPIs . So Event loop takes first from WebAPIs and then put into callback queueu . 
And when normal execution of program completes , GEC also popped out and then it start taking from callback queue and put into callstack .

console.log("A")

document.getElementById('btn').addEventListener('click' , ()=>{
	console.log("clicking") ;
})

console.log("B")

Similarily DOM and addEventListener is WebAPIs not javascript things . In normal execution of code , this event listener will get registered with WebAPIs . 
and all execution will complete normally . Now whenever there is click on button , WebAPIs callback is triggered , and event loop will put that callback 
inside callback queue . And then from callback queue , it will get placed into callstack by event loop . and then it will get executed . 

****** something different **********
console.log("A")

setTimeout( ()=>{
	console.log('timer')
} , 5000 )

fetch('https://netflix.com' ).then((data)=>{
	console.log("data comes from netflix" , data) ;
})

console.log("B")

Normal execution is same , firs there will be GEC created in callstack and then code will executes synchrnously till second console . 
Now there will be 2 things in WebAPIs , first settimeout which is waiting in timers till 5 second . And second one is network request  . 
Now fetch will return promise . let suppose fetch method took 50 ms to get response from netflix . 
It will then get places into microtask queue . Now Microtask queue is same as callback queue but with higher priority . It works same as callback queue . 
Point to remember Promise have always higher priority among operation which takes time , because promise got places into microtask queue which have
higher priority . 

When all normal execution completes , then event loop first start picking from microtask queue . After taking all operation from microtask queue 
it then start taking from callback queue . 
So first output is from netflix and then there will be output of settimeout . 
Now there can be conditioin of starvation also for operation which is present inside callback queue . If there are lot of operation inside microtask queue , 
then operation inside callback queue have to wait for long period of time . 





====================================================== Normal Javascript =========================================================================

Each browser have its own javascript engine . Chrome have V8 engine , firefox have spidermonkey engine , edge have Chakra javascript engine and there are
many more javascript engine . one of it is Nodejs also which is built over chrome V8 engine . 

There is standard ECMAScript . ECMAScript (ES) is the official standard for scripting languages, most famously implemented by JavaScript. The standard is defined by Ecma International in the ECMA-262 specification and provides the core language features, syntax, and semantics that scripting languages must follow. 
ECMAScript is the blueprint for the language. It defines the rules for syntax (e.g., how to declare variables and write loops), the types of data that can be used (e.g., strings, numbers, objects), and other core features.

Similar to WebAPIs which provides console , network request , timers there is also provision in nodejs . These things are provided in Node either by inbuilt module 
like http( to make network request) , fs (for file manipulation) , path , os , event stream or either by its so called NPM which contains a lot and lot of package . 

Implementation of settimeout in browser and in nodejs may or may not same . They can be different . 


=================================================== Call Stack and Callback Queue =========================================

First: the Call Stack ü•û (think: a stack of plates)
The call stack is where JavaScript keeps track of what function is currently running.

How it works:
JavaScript runs one thing at a time
When a function starts ‚Üí it‚Äôs pushed onto the stack
When it finishes ‚Üí it‚Äôs popped off the stack

Example:
function sayHi() {
  console.log("Hi");
}
function start() {
  sayHi();
}
start();

What happens:
start() goes on the stack
sayHi() goes on the stack
"Hi" is printed
sayHi() is removed
start() is removed

================> Now: the Callback Queue ‚è≥ (think: a waiting line)
Some things in JavaScript take time, like:
setTimeout
fetching data
events (clicks, keypresses)
These do NOT go directly on the call stack.
Instead, their callbacks wait in the callback queue until JavaScript is free.










