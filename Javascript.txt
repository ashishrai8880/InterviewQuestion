1.	Closure  

closure is created when a child function keep the environment of the parent scope even after the parent function has already executed 

function foo() {
	let b = 1;
	function inner() {
		return b;
	}
	return inner;
}
let get_func_inner = foo();

console.log(get_func_inner()); //1
console.log(get_func_inner()); //1
console.log(get_func_inner());  //1


2.	Call , Apply and Bind() method In JS

Ans.  JavaScript provides three methods for manipulating the this keyword in functions: call(), apply(), and bind(). These methods allow you to change the context of the this keyword, which can be useful for controlling the behaviour of functions. 

	1. call(); (Call Method)
The call() method allows you to call a function with a specified this value and arguments provided individually. The first argument to call() sets the this value for the function being called, and the remaining arguments are passed to the function as arguments.

let userDetails = {
    name : 'Ashish Rai',
    age : 22 ,
    printDetails :function (){
        console.log(this.name);
    }
}

userDetails.printDetails();

let userDetails2 = {
    name : 'Baniya',
    age : 23 ,
}

userDetails.printDetails.call(userDetails2);

#Real Life Example
const fs = require('fs');

function logData() {
  console.log(this.filename);
}

const file = { filename: 'data.txt' };

// Using call to set 'this' context for logData function
fs.readFile('data.txt', 'utf8', function (err, data) {
  if (err) throw err;
  logData.call(file);  // Output: data.txt
});


userDetails.printDetails.apply(userDetails2 ,[ â€˜New Nameâ€™ , â€˜Another nameâ€™]);

const store = userDetails.printDetails.bind(userDetails2);\
store();

3.	Hoisting : 
ïƒ°	In JavaScript, Hoisting is the default behavior of moving all the declarations at the top of the scope before code execution. Basically, it gives us an advantage that no matter where functions and variables are declared, they are moved to the top of their scope regardless of whether their scope is global or local. 
ïƒ°	It allows us to call functions before even writing them in our code. 
Note: JavaScript only hoists declarations, not initializations.

fun();  //calling before declaration
function fun() {
  
  let name = 'Mukul Latiyan';
  console.log(name);
}

Isme variable and function declration top me ho jaata hai lekin initialization nhi hota . Or ye bas var k sath hota hai , let const k sath nhi hota .

Example of hoisting . 

1. console.log(a);
var a = 10;

## Output
undefined


2. var a = 10;
console.log(a);

## Output
10

3. console.log(a);
var a;
a = 5;

## Output
undefined

4. var a = 1;
function test() {
  console.log(a);
  var a = 2;
}
test();

## Output
undefined

5. var a = 1;
function test() {
  console.log(a);
}
test();

## Output
1

Key Interview Rules to Remember

âœ… var â†’ hoisted + initialized as undefined
âœ… let / const â†’ hoisted but TDZ applies
âœ… Function declarations â†’ fully hoisted
âŒ Function expressions â†’ behave like variables
âŒ Classes â†’ hoisted but not accessible before declaration


// =================================================================================================================================================================
============================================================  Temporal Dead Zone ===================================================================================
What is Temporal Dead Zone (TDZ) in JavaScript?

Temporal Dead Zone (TDZ) is the time between:
- when a variable is declared
- and when it is initialized

During this time, you cannot use the variable.
TDZ applies to let and const, not var.

Simple Definition (Interview-friendly)
Temporal Dead Zone is the period where a let or const variable exists but cannot be accessed until it is initialized.
If you try to access it â†’ âŒ ReferenceError

The TDZ starts from the beginning of the block until the variable is declared.
Variables declared with let and const are hoisted but not initialized.
Accessing the variable in the TDZ results in a ReferenceError.
var declarations do not have a TDZ and are initialized as undefined.

Understanding Variable Hoisting
To grasp TDZ, itâ€™s important to understand hoisting. Hoisting is JavaScript's behaviour of moving variable and function declarations to the top of their containing scope during compilation.

var declarations are hoisted and initialized with undefined.
let and const declarations are hoisted but not initialized, leading to the TDZ.
Hoisting with var

console.log(a); // undefined
var a = 5;

Output
undefined
Here, a is hoisted to the top of its scope and initialized with undefined, so accessing it before the declaration doesnâ€™t throw an error.

Temporal Dead Zone with let

console.log(b); // ReferenceError: Cannot access 'b' before initialization
let b = 10;
In this case, b is hoisted but not initialized, so accessing it before the declaration results in a ReferenceError.

Examples to Illustrate Temporal Dead Zone
1. Accessing let and const Before Declaration

function gfg() {
    console.log(x); // ReferenceError
    let x = 3;
}
gfg();

2. Block Scope and TDZ

{
    console.log(y); // ReferenceError
    const y = 7;
}

3. Variables Declared After a Condition

if (true) {
    console.log(z); // ReferenceError
    let z = 9;
}

4. No Temporal Dead Zone with var
{
    console.log(a); // undefined
    var a = 5;
}
Understanding the Flow of TDZ
The Temporal Dead Zone works in the following manner

Variable is declared with let or const: When the variable is hoisted at the top of its current scope but they are not initialized.
Entering TDZ: From the hoisting till the variable initialization it will show the reference error if tried to access.
Variable initialization: When the value is assigned to the variable from that point of time they exits no longer in the TDZ.
Accessing the variable: The variables can be accessed normally after the initialization without any erros.

Why Does Temporal Dead Zone Exist?
In ES6 (ECMAScript 2015) the concept of the Temporal Dead was introduced to prevent the issues which was occurring during the variable hoisting.
When the TDZ concept was not introduced at that time the variables declared with var was automatically set to undefined which was causing the bugs or the issues.
To avoid such problems, Temporal Dead Zone ensures that only let and const variables are only accessible after being initialized.

Interview ready made examples 
1. console.log(a); // âŒ ReferenceError
let a = 10;

a is known to JavaScript
but not initialized yet
so it is in TDZ

Timeline Visualization
{
  // TDZ starts
  console.log(x); // âŒ ReferenceError

  let x = 5; // TDZ ends
  console.log(x); // âœ… 5
}

Key Difference
Keyword		Hoisted		TDZ
var			Yes			âŒ No
let			Yes			âœ… Yes
const		Yes			âœ… Yes

ðŸ”‘ let and const are hoisted but not initialized

Why Does TDZ Exist?
Interview answer:
TDZ helps catch bugs by preventing access to variables before they are properly declared.

2ï¸âƒ£ Does TDZ apply to var?
Answer:
No. TDZ only applies to let and const. var variables are initialized with undefined.

3ï¸âƒ£ Are let and const hoisted?
Answer:
Yes, they are hoisted but not initialized. Thatâ€™s why accessing them before declaration causes TDZ.

4ï¸âƒ£ What error occurs in TDZ?
Answer:
ReferenceError

5ï¸âƒ£ When does TDZ start and end?
Answer:
Starts at the beginning of the block
Ends when the variable is declared and initialized

6ï¸âƒ£ Does TDZ exist inside functions and blocks?
Answer:
Yes. TDZ is block-scoped, so it applies inside { } blocks and functions.

7ï¸âƒ£ Example question: What is the output?
{
  console.log(a);
  let a = 10;
}
Answer:
âŒ ReferenceError (because a is in TDZ)

8ï¸âƒ£ Why doesnâ€™t this cause an error?
let a = 10;
console.log(a);
Answer:
Because a is accessed after initialization, so TDZ is over.

9ï¸âƒ£ Is this TDZ?
let a;
console.log(a);
Answer:
âŒ No TDZ error
a is already initialized with undefined

ðŸ”Ÿ Does const behave differently from let in TDZ?
Answer:
No. Both have TDZ.
But const must be initialized immediately.
const x; // âŒ SyntaxError

ðŸ”Ÿ
console.log(a);
let a = 10;

Output:
ReferenceError
Why: let is hoisted but not initialized (TDZ).


ðŸ”Ÿ
let a = 10;
{
  console.log(a);
}

Output:
10

ðŸ”Ÿ
const a = 10;
a = 20;
console.log(a);

Output:
TypeError

ðŸ”¹ 3. Function Declarations vs Function Expressions

ðŸ”Ÿ
hello();
function hello() {
  console.log("Hello");
}

Output:
Hello
Why: Function declarations are fully hoisted.

ðŸ”Ÿ
hello();

var hello = function () {
  console.log("Hello");
};

Output:
TypeError
Why: TypeError: hello is not a function

ðŸ”Ÿ
console.log(test);
function test() {}

Output:
ReferenceError
Why: let is hoisted but not initialized (TDZ).

ðŸ”Ÿ
console.log(a);
let a = 10;

Output:
Æ’ test() {}

ðŸ”Ÿ
console.log(test);
var test = function () {};

Output:
undefined

ðŸ”¹ 4. Hoisting Inside Functions

ðŸ”Ÿ
function foo() {
  console.log(a);
  a = 10;
}
foo();

Output:
ReferenceError
Why: a is not declared.

ðŸ”Ÿ
function foo() {
  console.log(a);
  var a = 10;
}
foo();

Output:
undefined

ðŸ”Ÿ
var a = 5;
(function () {
  console.log(a);
  var a = 10;
})();

Output:
undefined

ðŸ”¹ 5. Class Hoisting

ðŸ”Ÿ
const obj = new MyClass();
class MyClass {}

Output:
ReferenceError
Why: Classes are hoisted but in TDZ (like let).

ðŸ”¹ 6. Mixed Hoisting Tricky Questions

ðŸ”Ÿ
var x = 10;
function test() {
  console.log(x);
  var x = 20;
}
test();

Output:
undefined

ðŸ”Ÿ
function test() {
  console.log(x);
}
test();
var x = 5;

Output:
undefined

ðŸ”Ÿ
console.log(typeof a);
var a = 10;

Output:
undefined

==================================================================================================================================================================================================================================================================================================================================

4. What is first class function ?
Ans .  A programming language is said to have First-class functions if functions in that language are treated like other variables. So the functions can be assigned to any other variable or passed as an argument or can be returned by another function. JavaScript treats function as a first-class citizen.

const Geek = (a, b) => {
    return (a + " " + b);
}

5. What is Nodejs 
Ans . Node.js is a virtual machine that uses JavaScript as its scripting language and runs Chromeâ€™s V8 JavaScript engine. Basically, Node.js is based on an event-driven architecture where I/O runs asynchronously making it lightweight and efficient .

6. What is Promise ?
Ans . In JavaScript, a Promise is an object that will produce a single value some time in the future. If the promise is successful, it will produce a resolved value, but if something goes wrong then it will produce a reason why the promise failed. The possible outcomes here are similar to that of promises in real life.

JavaScript promises can be in one of three possible states. These states indicate the progress of the promise. They are:

pending: This is the default state of a defined promise
fulfilled:  This is the state of a successful promise
rejected: This is the state of a failed promise

Example : const promise = new Promise((resolve, reject) => {
  const num = Math.random();
  if (num >= 0.5) {
    resolve("Promise is fulfilled!");
  } else {
    reject("Promise failed!");
  }
});

7. What is fork in node JS?
Ans : A fork in general is used to spawn child processes. In node it is used to create a new instance of v8 engine to run multiple workers to execute the code

8. What is callback in NodeJs ?
Ans : Node. js callbacks are a special type of function passed as an argument to another function. They're called when the function that contains
the callback as an argument completes its execution, and allows the code in the callback to run in the meantime. Callbacks help us make 
asynchronous calls


9. What is deep copy and shallow copy ?
Ans : A shallow copy occurs when you copy the reference of an object to a new variable. In this process, only the
top-level properties are copied, while nested objects or arrays still reference the original memory location. This 
means that if you change the nested properties in one object, those changes will reflect in the other because they 
share the same memory reference.

let employee = {
    eid: "E102",
    ename: "Jack",
    eaddress: "New York",
    salary: 50000
}

console.log("Employee=> ", employee);
let newEmployee = employee;    // Shallow copy
console.log("New Employee=> ", newEmployee);

console.log("---------After modification----------");
newEmployee.ename = "Beck";
console.log("Employee=> ", employee);
console.log("New Employee=> ", newEmployee);


Deep Copy
A deep copy, on the other hand, creates a completely independent copy of the object, including all nested objects or arrays. This ensures that changes made to one object do not affect the other. Each object is stored in a separate memory location, making them entirely independent.


======================================================= Event Loop In Browser Perspective =========================================================================

console.log("A")
func(){
	console.log("fun");
}
func()
console.log("B")

- Whatever piece of javascript code we write , first there will be Global Execution Context(GEC) created in callstack . Callstack is basically a place where code actually 
executes . Whatever inside callstack , it immediately executes . In GEC , our program executes line by line . Entire piece of code of program exists in GEC . 
So from line 1 , it executes first console , then there will be func() call in callstack on top of it , it will executes and then second console . 

There are some time taking process which can require resource like network request , i/o operation , timers . 
setTimeout , console , fetch , DOM , localStorage etc -> these are not javascript things , In web side , these are superpower provided by browser , these are not directly related to 
javascript . we can use these using window.console , window.fetch also . These all things comes under global variable called 'window' . 

There are WebAPIs which is responsible to executes these code in web side . All these things are available under WebAPIs . 


console.log("A")

setTimeout( ()=>{
	console.log('timer')
} , 5000 )

console.log("B")


Initial execution will be same , first there will be GEC created in callstack , then first line of console printed . And then there is setTimeout , so it will 
send to WebAPIs , and then it will print last console . 
After completion of 5 seconds in WebAPI , now the code is ready to executes . But wait wait , how the callback function entered into callstack , who will take that 
function into callstack . Because we know everything which executes is under callstack .

Here comes in picture of Event Loop . Now event loop will take that function callback inside callstack . But wait again , does event loop direcly takes from 
WebAPIs . No . There is one more middle man comes in between which is Callback Queue . 

Callback Queue -> It basically stores all the callback which is coming from WebAPIs . So Event loop takes first from WebAPIs and then put into callback queueu . 
And when normal execution of program completes , GEC also popped out and then it start taking from callback queue and put into callstack .

console.log("A")

document.getElementById('btn').addEventListener('click' , ()=>{
	console.log("clicking") ;
})

console.log("B")

Similarily DOM and addEventListener is WebAPIs not javascript things . In normal execution of code , this event listener will get registered with WebAPIs . 
and all execution will complete normally . Now whenever there is click on button , WebAPIs callback is triggered , and event loop will put that callback 
inside callback queue . And then from callback queue , it will get placed into callstack by event loop . and then it will get executed . 

****** something different **********
console.log("A")

setTimeout( ()=>{
	console.log('timer')
} , 5000 )

fetch('https://netflix.com' ).then((data)=>{
	console.log("data comes from netflix" , data) ;
})

console.log("B")

Normal execution is same , firs there will be GEC created in callstack and then code will executes synchrnously till second console . 
Now there will be 2 things in WebAPIs , first settimeout which is waiting in timers till 5 second . And second one is network request  . 
Now fetch will return promise . let suppose fetch method took 50 ms to get response from netflix . 
It will then get places into microtask queue . Now Microtask queue is same as callback queue but with higher priority . It works same as callback queue . 
Point to remember Promise have always higher priority among operation which takes time , because promise got places into microtask queue which have
higher priority . 

When all normal execution completes , then event loop first start picking from microtask queue . After taking all operation from microtask queue 
it then start taking from callback queue . 
So first output is from netflix and then there will be output of settimeout . 
Now there can be conditioin of starvation also for operation which is present inside callback queue . If there are lot of operation inside microtask queue , 
then operation inside callback queue have to wait for long period of time . 





====================================================== Normal Javascript =========================================================================

Each browser have its own javascript engine . Chrome have V8 engine , firefox have spidermonkey engine , edge have Chakra javascript engine and there are
many more javascript engine . one of it is Nodejs also which is built over chrome V8 engine . 

There is standard ECMAScript . ECMAScript (ES) is the official standard for scripting languages, most famously implemented by JavaScript. The standard is defined by Ecma International in the ECMA-262 specification and provides the core language features, syntax, and semantics that scripting languages must follow. 
ECMAScript is the blueprint for the language. It defines the rules for syntax (e.g., how to declare variables and write loops), the types of data that can be used (e.g., strings, numbers, objects), and other core features.

Similar to WebAPIs which provides console , network request , timers there is also provision in nodejs . These things are provided in Node either by inbuilt module 
like http( to make network request) , fs (for file manipulation) , path , os , event stream or either by its so called NPM which contains a lot and lot of package . 

Implementation of settimeout in browser and in nodejs may or may not same . They can be different . 











