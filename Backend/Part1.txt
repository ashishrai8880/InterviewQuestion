---------------------------------> What is libuv? (Interview Definition)

libuv is a C library used by Node.js that provides the event loop and handles asynchronous, non-blocking operations such as file I/O, networking, timers, and background 
tasks.
Node.js itself is JavaScript, but:

OS-level async I/O
Thread management
Event polling

ğŸ‘‰ These are handled by libuv.

libuv is a C library used by Node.js that provides the event loop and handles asynchronous, non-blocking operations like file I/O, networking, timers, and
background tasks. It uses OS-level async APIs and a thread pool to execute slow operations without blocking the main JavaScript thread, allowing Node.js to
scale efficiently while remaining single-threaded at the JavaScript level.

2ï¸âƒ£ Why Node.js Needs libuv
JavaScript is single-threaded.

Without libuv:
File reads would block the entire process
Network requests would block execution
Node.js wouldnâ€™t scale

libuv allows Node.js to:
Stay single-threaded at the JS level
Still handle thousands of concurrent operations
Use OS async APIs efficiently

3ï¸âƒ£ Core Responsibilities of libuv
âœ… 1. Event Loop
libuv implements the event loop.
It:
Waits for async operations to complete
Pushes their callbacks to the JS execution stack
Ensures non-blocking execution

Event loop phases include:
Timers , I/O callbacks ,Poll ,Check , Close callbacks

âœ… 2. Asynchronous I/O (Non-Blocking)

libuv handles:
Network I/O (TCP, HTTP, sockets) â†’ mostly OS async
File system I/O â†’ thread pool

Example:

fs.readFile("file.txt", callback)

Behind the scenes:
libuv sends the task to a worker thread
JS thread continues execution
Callback is queued when done


-----------------------------------------> difference between nextTick , setTimeout and setImmediate <----------------------

1ï¸âƒ£ process.nextTick()
Runs immediately after the current code finishes, before the event loop continues.
ğŸ‘‰ Think of it as: â€œRun this before anything else.â€

process.nextTick(() => {
  console.log("nextTick");
});

Key points
Runs before setTimeout and setImmediate
Executes before the event loop moves to the next phase
Can block the event loop if used too much
"process.nextTick schedules a callback to run right after the current operation, before the event loop continues."

2ï¸âƒ£ setTimeout()
Runs after a minimum delay (timer phase). "setTimeout runs a callback after a specified delay, once the timers phase is reached."

setTimeout(() => {
  console.log("timeout");
}, 0);

Key points
Executes after the given time (not guaranteed exact timing)
Even 0 ms means â€œrun laterâ€
Happens in the Timers phase of the event loop

3ï¸âƒ£ setImmediate()
Runs after I/O events are processed. "setImmediate runs a callback after I/O operations, in the check phase of the event loop."

setImmediate(() => {
  console.log("immediate");
});

Key points
Executes in the Check phase
Often runs after I/O callbacks
Designed for tasks that should run right after I/O

ğŸ”¥ Common interview example

console.log("start");

process.nextTick(() => console.log("nextTick"));
setTimeout(() => console.log("timeout"), 0);
setImmediate(() => console.log("immediate"));

console.log("end");

--------------Output (most cases)
start
end
nextTick
timeout
immediate

ğŸ“ One-line memory trick
nextTick â†’ before event loop
setTimeout â†’ after time
setImmediate â†’ after I/O


============================================ Phases Of Event Loop ==================================================
Best Video : https://www.youtube.com/watch?v=F87zTwgaqSo


   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”Œâ”€>â”‚           timers          â”‚    - settimeout , settimeinterval and other timers callback 
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  â”‚     pending callbacks     â”‚    - system error cb , DNS cb , network failure cb 
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  â”‚       idle, prepare       â”‚    - internally used by event loop for preparing for next phase . 
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”‚   incoming:   â”‚     - all the cb are registered here except settimeout , setinterval
â”‚  â”‚           poll            â”‚<â”€â”€â”€â”€â”€â”¤  connections, â”‚        setimmediate , close cb . Every cb is registered here like 
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â”‚   data, etc.  â”‚        network cb , i/o cb or any other cb . 
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”‚  â”‚           check           â”‚      - setImmediate callback is registered here . And it will execute just after 
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        i/o operation .
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â””â”€â”€â”¤      close callbacks      â”‚      - socket.on('disconnect' , cb) , or any close cb are registered here . 
   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


The Node.js event loop operates in a specific sequence of six phases, each managing a FIFO queue of callbacks to execute.
This mechanism allows Node.js to perform non-blocking I/O operations and handle concurrency efficiently within a single main
thread. 

Any Network request goes to OS kernel , file IO request also goes to OS . Phases of Event Loop is nothing but a 
multiple Queue . 

All above phases like queue  , basically callback hi store karega . jaise settimeout hai , to iska time pura hone pe
iska callback timers phase/queue k andar store ho jayega . 


Example 1 : 

setTimeout(()=>{
    console.log("SetTimeout")
} , 0)


setImmediate(()=>{
    console.log("SetImmediate")
} )

// Output 
SetImmediate
SetTimeout

Now it is not always necessary that setImmediate will always comes first . But sometimes setTimeout can also comes first . 
Ye uncertain hai . Jayadatar case me uper wala hi output rhega . depend krega , event loop kon se phase me hai . 
agar event loop close cb phase me hai , to pehle settiemout print krega , kyuki iske baad wo timer phase me jayega . 

Example 2 : 
setImmediate(()=>{console.log("SetImmediate 1")} )
setImmediate(()=>{console.log("SetImmediate 2")} )

setTimeout(()=>{console.log("SetTimeout 1")} , 0)
setTimeout(()=>{console.log("SetTimeout 2")} , 0)

### Output
SetImmediate 1
SetTimeout 1
SetImmediate 2
SetTimeout 2

Example 3: 

const fs = require('fs');

fs.readFile(__filename , ()=>{
  setTimeout(()=>{console.log("SetTimeout 1")} , 0)
  setImmediate(()=>{console.log("SetImmediate 2")} )
})

console.log("start")

#####Output:

start
SetImmediate 2
SetTimeout 1


****************************************** Event Emitter ***************************************************
The EventEmitter is a core component of Node.js that facilitates an asynchronous, event-driven architecture. It implements
the publisher-subscriber pattern, allowing objects to emit named events (publish) and register functions (listeners or 
subscribers) to respond to those events. 

The EventEmitter class in NodeJS is a core module that provides a way to handle asynchronous events. It allows objects to 
emit events and other objects to listen and respond to those events.

const EventEmitter = require('events');

const event = new EventEmitter();

event.on("won" , (d)=>{
  console.log("First Won Event Fired : " , d)
})

event.on("won" , ()=>{
  console.log("Second Won Event Fired")
})

event.on("loss" , ()=>{
  console.log("Loss Event Fired")
})

event.emit("won" , "dummy data")


************************************************ Concurrency and Parallelism **********************************************
Concurrency is about dealing with many tasks at once, even if theyâ€™re not all running at the exact same moment.
The program switches between tasks
Tasks overlap in time
Often used to keep programs responsive

Analogy:
Youâ€™re doing homework, then checking a text, then going back to homework. Youâ€™re not doing both at the same time, but youâ€™re handling both.

Task A runs a bit â†’ Task B runs a bit â†’ Task A again â†’ ...

âš¡ Parallelism
Parallelism is about doing multiple tasks at the exact same time.
Requires multiple CPU cores
Tasks truly run simultaneously
Focused on speed

Analogy:
You and a friend clean different rooms at the same time.

Example:
A video editor that:
processes multiple video frames at once
each frame runs on a different CPU core

Core 1: Task A
Core 2: Task B   (at the same time)

You can have:
Concurrency without parallelism (single-core CPU)
Parallelism with concurrency (multi-core CPU running many tasks)

ğŸš€ Simple Rule to Remember
Concurrency = managing many things
Parallelism = doing many things at once
