



=======> 7. Highest Salary Per Department 

Topic : Corelated Subquery : So Inner query will be completely dependent on Outer Query . Can be used as alternate of
Group By clause in some case also . 
Eg : Tables (very small & real)
employees table
emp_id	          name	                dept	              salary
1	                Alice	                HR	                5000
2	                Bob	                  HR	                7000
3	                Carol	                IT	                9000
4	                Dave	                IT	                6000
5	                Eve	                  IT	                8000

ðŸ‘‰ Question:
â€œShow me employees who earn more than the average salary of their own department.â€
Key point:
The â€œaverageâ€ is different for each department.

So you cannot calculate one single average and compare everyone to it.
What we want (expected result)

Letâ€™s calculate manually:
HR department
    Salaries: 5000, 7000
    Average = 6000
    Above avg â†’ Bob

IT department
    Salaries: 9000, 6000, 8000
    Average = 7666
    Above avg â†’ Carol

----------Correlated subquery (the SQL)
SELECT e1.name, e1.dept, e1.salary
FROM employees e1
WHERE e1.salary >
      (SELECT AVG(e2.salary)
       FROM employees e2
       WHERE e2.dept = e1.dept);

--------------How it REALLY works (row by row â€“ think loop)
Step 1: Pick ONE row from outer query
Outer query (e1) picks:

Alice | HR | 5000

Step 2: Run subquery USING Aliceâ€™s department
Subquery becomes:

SELECT AVG(salary)
FROM employees
WHERE dept = 'HR';

Result = 6000
Now SQL checks:

Is 5000 > 6000 ? âŒ No

âž¡ Alice is skipped

Step 3: Next outer row
Bob | HR | 7000

Subquery becomes:

SELECT AVG(salary)
FROM employees
WHERE dept = 'HR';

Result = 6000

Check:
Is 7000 > 6000 ? âœ… Yes

âž¡ Bob is included

Step 4: Next row
Carol | IT | 9000

Subquery becomes:

SELECT AVG(salary)
FROM employees
WHERE dept = 'IT';

Result = 7666

Check:
Is 9000 > 7666 ? âœ… Yes

âž¡ Carol is included

Now Actual Leetcode Question : https://leetcode.com/problems/department-highest-salary/

+--------------+---------+
| Column Name  | Type    |
+--------------+---------+
| id           | int     |
| name         | varchar |
| salary       | int     |
| departmentId | int     |
+--------------+---------+
id is the primary key (column with unique values) for this table.
departmentId is a foreign key (reference columns) of the ID from the Department table.
Each row of this table indicates the ID, name, and salary of an employee. It also contains the ID of their department.
 

Table: Department

+-------------+---------+
| Column Name | Type    |
+-------------+---------+
| id          | int     |
| name        | varchar |
+-------------+---------+
id is the primary key (column with unique values) for this table. It is guaranteed that department name is not NULL.
Each row of this table indicates the ID of a department and its name.
 

Write a solution to find employees who have the highest salary in each of the departments.

Return the result table in any order.

The result format is in the following example.

 

Example 1:

Input: 
Employee table:
+----+-------+--------+--------------+
| id | name  | salary | departmentId |
+----+-------+--------+--------------+
| 1  | Joe   | 70000  | 1            |
| 2  | Jim   | 90000  | 1            |
| 3  | Henry | 80000  | 2            |
| 4  | Sam   | 60000  | 2            |
| 5  | Max   | 90000  | 1            |
+----+-------+--------+--------------+
Department table:
+----+-------+
| id | name  |
+----+-------+
| 1  | IT    |
| 2  | Sales |
+----+-------+
Output: 
+------------+----------+--------+
| Department | Employee | Salary |
+------------+----------+--------+
| IT         | Jim      | 90000  |
| Sales      | Henry    | 80000  |
| IT         | Max      | 90000  |
+------------+----------+--------+
Explanation: Max and Jim both have the highest salary in the IT department and Henry has the highest salary in the Sales department.

Solution 1 : Using Corelated Subquery

          select d.name AS Department,
              e.name AS Employee,
              e.salary AS Salary
          from Employee as e
          join Department as d 
          on e.departmentId = d.id 
          where e.salary in
          (
              select max(e2.salary)
              from Employee as e2
              where e.departmentId = e2.departmentId
          )

Solution 2 : Using JOIN and GROUP BY

          select 
              d.name AS Department,
              e.name AS Employee,
              e.salary AS Salary
          from Employee as e
          join (
              select departmentId , max(salary) as max_salary
              from Employee 
              group by departmentId
          ) as m 
          on e.departmentId = m.departmentId and e.salary = m.max_salary
          join Department as d
          on e.departmentId = d.id

Solution 3 : Using Window Function 

          SELECT
              d.name AS Department,
              e.name AS Employee,
              e.salary AS Salary
          FROM (
              SELECT *,
                     MAX(salary) OVER (PARTITION BY departmentId) AS max_salary
              FROM Employee
          ) e
          JOIN Department d
              ON e.departmentId = d.id
          WHERE e.salary = e.max_salary;

Solution 4 : Using RANK and DenseRank()

          SELECT
              d.name AS Department,
              e.name AS Employee,
              e.salary AS Salary
          FROM (
              SELECT *,
                     DENSE_RANK() OVER (
                         PARTITION BY departmentId
                         ORDER BY salary DESC
                     ) AS rnk
              FROM Employee
          ) e
          JOIN Department d
              ON e.departmentId = d.id
          WHERE e.rnk = 1;

--------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------

8. https://leetcode.com/problems/group-sold-products-by-the-date/description/
+-------------+---------+
| Column Name | Type    |
+-------------+---------+
| sell_date   | date    |
| product     | varchar |
+-------------+---------+
There is no primary key (column with unique values) for this table. It may contain duplicates.
Each row of this table contains the product name and the date it was sold in a market.
 

Write a solution to find for each date the number of different products sold and their names.

The sold products names for each date should be sorted lexicographically.

Return the result table ordered by sell_date.

The result format is in the following example.

 

Example 1:

Input: 
Activities table:
+------------+------------+
| sell_date  | product     |
+------------+------------+
| 2020-05-30 | Headphone  |
| 2020-06-01 | Pencil     |
| 2020-06-02 | Mask       |
| 2020-05-30 | Basketball |
| 2020-06-01 | Bible      |
| 2020-06-02 | Mask       |
| 2020-05-30 | T-Shirt    |
+------------+------------+
Output: 
+------------+----------+------------------------------+
| sell_date  | num_sold | products                     |
+------------+----------+------------------------------+
| 2020-05-30 | 3        | Basketball,Headphone,T-shirt |
| 2020-06-01 | 2        | Bible,Pencil                 |
| 2020-06-02 | 1        | Mask                         |
+------------+----------+------------------------------+

Solution : Using string_agg
        SELECT
            sell_date,
            COUNT(product) AS num_sold,
            STRING_AGG(product, ',' ORDER BY product) AS products
        FROM (
            SELECT DISTINCT sell_date, product
            FROM Activities
        ) t
        GROUP BY sell_date
        ORDER BY sell_date;

Explanation : STRING_AGG . Link : https://www.geeksforgeeks.org/sql-server/how-to-use-string_agg-to-concatenate-strings-in-sql-server/
This functioin basically used to concatenate string . Used with GROUP BY clause . 


--------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------
9. https://leetcode.com/problems/market-analysis-i/description/

Table: Users

+----------------+---------+
| Column Name    | Type    |
+----------------+---------+
| user_id        | int     |
| join_date      | date    |
| favorite_brand | varchar |
+----------------+---------+
user_id is the primary key (column with unique values) of this table.
This table has the info of the users of an online shopping website where users can sell and buy items.
 

Table: Orders

+---------------+---------+
| Column Name   | Type    |
+---------------+---------+
| order_id      | int     |
| order_date    | date    |
| item_id       | int     |
| buyer_id      | int     |
| seller_id     | int     |
+---------------+---------+
order_id is the primary key (column with unique values) of this table.
item_id is a foreign key (reference column) to the Items table.
buyer_id and seller_id are foreign keys to the Users table.
 

Table: Items

+---------------+---------+
| Column Name   | Type    |
+---------------+---------+
| item_id       | int     |
| item_brand    | varchar |
+---------------+---------+
item_id is the primary key (column with unique values) of this table.
 

Write a solution to find for each user, the join date and the number of orders they made as a buyer in 2019.

Return the result table in any order.

The result format is in the following example.

 

Example 1:

Input: 
Users table:
+---------+------------+----------------+
| user_id | join_date  | favorite_brand |
+---------+------------+----------------+
| 1       | 2018-01-01 | Lenovo         |
| 2       | 2018-02-09 | Samsung        |
| 3       | 2018-01-19 | LG             |
| 4       | 2018-05-21 | HP             |
+---------+------------+----------------+
Orders table:
+----------+------------+---------+----------+-----------+
| order_id | order_date | item_id | buyer_id | seller_id |
+----------+------------+---------+----------+-----------+
| 1        | 2019-08-01 | 4       | 1        | 2         |
| 2        | 2018-08-02 | 2       | 1        | 3         |
| 3        | 2019-08-03 | 3       | 2        | 3         |
| 4        | 2018-08-04 | 1       | 4        | 2         |
| 5        | 2018-08-04 | 1       | 3        | 4         |
| 6        | 2019-08-05 | 2       | 2        | 4         |
+----------+------------+---------+----------+-----------+
Items table:
+---------+------------+
| item_id | item_brand |
+---------+------------+
| 1       | Samsung    |
| 2       | Lenovo     |
| 3       | LG         |
| 4       | HP         |
+---------+------------+
Output: 
+-----------+------------+----------------+
| buyer_id  | join_date  | orders_in_2019 |
+-----------+------------+----------------+
| 1         | 2018-01-01 | 1              |
| 2         | 2018-02-09 | 2              |
| 3         | 2018-01-19 | 0              |
| 4         | 2018-05-21 | 0              |
+-----------+------------+----------------+


Solution : 
        SELECT
            u.user_id AS buyer_id,
            u.join_date,
            COUNT(o.order_id) AS orders_in_2019
        FROM Users u
        LEFT JOIN Orders o
            ON u.user_id = o.buyer_id
           AND o.order_date >= DATE '2019-01-01'
           AND o.order_date <  DATE '2020-01-01'
        GROUP BY u.user_id, u.join_date;


--------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------
10. https://leetcode.com/problems/nth-highest-salary/
+-------------+------+
| Column Name | Type |
+-------------+------+
| id          | int  |
| salary      | int  |
+-------------+------+
id is the primary key (column with unique values) for this table.
Each row of this table contains information about the salary of an employee.
 

Write a solution to find the nth highest distinct salary from the Employee table. If there are less than n distinct salaries, return null.

The result format is in the following example.

Example 1:

Input: 
Employee table:
+----+--------+
| id | salary |
+----+--------+
| 1  | 100    |
| 2  | 200    |
| 3  | 300    |
+----+--------+
n = 2
Output: 
+------------------------+
| getNthHighestSalary(2) |
+------------------------+
| 200                    |
+------------------------+
Example 2:

Input: 
Employee table:
+----+--------+
| id | salary |
+----+--------+
| 1  | 100    |
+----+--------+
n = 2
Output: 
+------------------------+
| getNthHighestSalary(2) |
+------------------------+
| null                   |
+------------------------+

Solution : CREATE OR REPLACE FUNCTION NthHighestSalary(N INT) RETURNS TABLE (Salary INT) AS $$
BEGIN
  RETURN QUERY (
    -- Write your PostgreSQL query statement below.
    
      select distinct e.salary 
      from Employee e
      order by e.salary desc 
      offset N - 1
      limit 1

  );
END;
$$ LANGUAGE plpgsql;


--------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------
11. https://leetcode.com/problems/rank-scores/description/

Table: Scores

+-------------+---------+
| Column Name | Type    |
+-------------+---------+
| id          | int     |
| score       | decimal |
+-------------+---------+
id is the primary key (column with unique values) for this table.
Each row of this table contains the score of a game. Score is a floating point value with two decimal places.
 
Write a solution to find the rank of the scores. The ranking should be calculated according to the following rules:

The scores should be ranked from the highest to the lowest.
If there is a tie between two scores, both should have the same ranking.
After a tie, the next ranking number should be the next consecutive integer value. In other words, there should be no holes between ranks.
Return the result table ordered by score in descending order.

The result format is in the following example.

Example 1:

Input: 
Scores table:
+----+-------+
| id | score |
+----+-------+
| 1  | 3.50  |
| 2  | 3.65  |
| 3  | 4.00  |
| 4  | 3.85  |
| 5  | 4.00  |
| 6  | 3.65  |
+----+-------+
Output: 
+-------+------+
| score | rank |
+-------+------+
| 4.00  | 1    |
| 4.00  | 1    |
| 3.85  | 2    |
| 3.65  | 3    |
| 3.65  | 3    |
| 3.50  | 4    |
+-------+------+


Solutioin : select score , DENSE_RANK() over( order by score desc) as rank
            from Scores ;


--------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------
12: https://leetcode.com/problems/consecutive-numbers/description/

+-------------+---------+
| Column Name | Type    |
+-------------+---------+
| id          | int     |
| num         | varchar |
+-------------+---------+
In SQL, id is the primary key for this table.
id is an autoincrement column starting from 1.
 

Find all numbers that appear at least three times consecutively.

Return the result table in any order.

The result format is in the following example.

 

Example 1:

Input: 
Logs table:
+----+-----+
| id | num |
+----+-----+
| 1  | 1   |
| 2  | 1   |
| 3  | 1   |
| 4  | 2   |
| 5  | 1   |
| 6  | 2   |
| 7  | 2   |
+----+-----+
Output: 
+-----------------+
| ConsecutiveNums |
+-----------------+
| 1               |
+-----------------+
Explanation: 1 is the only number that appears consecutively for at least three times.

Solution : 

select distinct(t.num) as ConsecutiveNums 
from 
    (select num ,
        lag(num , 1) over(order by id) as prev1 ,
        lag(num , 2) over(order by id) as prev2

    from Logs ) as t
where t.num = t.prev1 and t.prev1 = t.prev2 ;

--------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------
13:  https://leetcode.com/problems/duplicate-emails/submissions/1908957016/
Write a solution to report all the duplicate emails. Note that it's guaranteed that the email field is not NULL.

Return the result table in any order.

The result format is in the following example.

 

Example 1:

Input: 
Person table:
+----+---------+
| id | email   |
+----+---------+
| 1  | a@b.com |
| 2  | c@d.com |
| 3  | a@b.com |
+----+---------+
Output: 
+---------+
| Email   |
+---------+
| a@b.com |
+---------+
Explanation: a@b.com is repeated two times.

Solution : 

select email as Email
from Person
group by email
having count(*) > 1

--------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------
14. https://leetcode.com/problems/not-boring-movies/description/


Write a solution to report the movies with an odd-numbered ID and a description that is not "boring".

Return the result table ordered by rating in descending order.

The result format is in the following example.

Example 1:

Input: 
Cinema table:
+----+------------+-------------+--------+
| id | movie      | description | rating |
+----+------------+-------------+--------+
| 1  | War        | great 3D    | 8.9    |
| 2  | Science    | fiction     | 8.5    |
| 3  | irish      | boring      | 6.2    |
| 4  | Ice song   | Fantacy     | 8.6    |
| 5  | House card | Interesting | 9.1    |
+----+------------+-------------+--------+
Output: 
+----+------------+-------------+--------+
| id | movie      | description | rating |
+----+------------+-------------+--------+
| 5  | House card | Interesting | 9.1    |
| 1  | War        | great 3D    | 8.9    |
+----+------------+-------------+--------+
Explanation: 
We have three movies with odd-numbered IDs: 1, 3, and 5. The movie with ID = 3 is boring so we do not include it in the answer.

Solution : 

select * 
from Cinema as c 
where mod(id , 2) = 1 and c."description" <> 'boring'
order by rating  desc 

--------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------
15. https://leetcode.com/problems/rising-temperature/description/


Write a solution to find all dates' id with higher temperatures compared to its previous dates (yesterday).

Return the result table in any order.
The result format is in the following example.

Example 1:

Input: 
Weather table:
+----+------------+-------------+
| id | recordDate | temperature |
+----+------------+-------------+
| 1  | 2015-01-01 | 10          |
| 2  | 2015-01-02 | 25          |
| 3  | 2015-01-03 | 20          |
| 4  | 2015-01-04 | 30          |
+----+------------+-------------+
Output: 
+----+
| id |
+----+
| 2  |
| 4  |
+----+
Explanation: 
In 2015-01-02, the temperature was higher than the previous day (10 -> 25).
In 2015-01-04, the temperature was higher than the previous day (20 -> 30).

Solution : 

select w1.id
from Weather w1 
join Weather w2
on w1.recordDate = w2.recordDate + INTERVAL '1 day'
where w1.temperature > w2.temperature 


--------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------
16.  https://leetcode.com/problems/calculate-special-bonus/description/

Write a solution to calculate the bonus of each employee. The bonus of an employee is 100% of their salary if the ID of the 
employee is an odd number and the employee's name does not start with the character 'M'. The bonus of an employee is 0 
otherwise.

Return the result table ordered by employee_id.

The result format is in the following example.

Example 1:

Input: 
Employees table:
+-------------+---------+--------+
| employee_id | name    | salary |
+-------------+---------+--------+
| 2           | Meir    | 3000   |
| 3           | Michael | 3800   |
| 7           | Addilyn | 7400   |
| 8           | Juan    | 6100   |
| 9           | Kannon  | 7700   |
+-------------+---------+--------+
Output: 
+-------------+-------+
| employee_id | bonus |
+-------------+-------+
| 2           | 0     |
| 3           | 0     |
| 7           | 7400  |
| 8           | 0     |
| 9           | 7700  |
+-------------+-------+
Explanation: 
The employees with IDs 2 and 8 get 0 bonus because they have an even employee_id.
The employee with ID 3 gets 0 bonus because their name starts with 'M'.
The rest of the employees get a 100% bonus.

select 
    employee_id,
    case 
        when mod(employee_id , 2) = 1 and name not like 'M%'
        then salary 
        else 0
    end as bonus
from Employees 
order by employee_id

--------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------
17.  https://leetcode.com/problems/replace-employee-id-with-the-unique-identifier/description/


Write a solution to show the unique ID of each user, If a user does not have a unique ID replace just show null.

Return the result table in any order.
The result format is in the following example.

Example 1:

Input: 
Employees table:
+----+----------+
| id | name     |
+----+----------+
| 1  | Alice    |
| 7  | Bob      |
| 11 | Meir     |
| 90 | Winston  |
| 3  | Jonathan |
+----+----------+
EmployeeUNI table:
+----+-----------+
| id | unique_id |
+----+-----------+
| 3  | 1         |
| 11 | 2         |
| 90 | 3         |
+----+-----------+
Output: 
+-----------+----------+
| unique_id | name     |
+-----------+----------+
| null      | Alice    |
| null      | Bob      |
| 2         | Meir     |
| 3         | Winston  |
| 1         | Jonathan |
+-----------+----------+
Explanation: 
Alice and Bob do not have a unique ID, We will show null instead.
The unique ID of Meir is 2.
The unique ID of Winston is 3.
The unique ID of Jonathan is 1.

Solution : 

select unique_id , name
from Employees as e 
left join EmployeeUNI as u
on e.id = u.id

--------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------
18. 



--------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------
19. https://leetcode.com/problems/find-total-time-spent-by-each-employee/description/

Write a solution to calculate the total time in minutes spent by each employee on each day at the office. Note that within one day, an employee can enter and leave more than once. The time spent in the office for a single entry is out_time - in_time.

Return the result table in any order.

The result format is in the following example.

Example 1:

Input: 
Employees table:
+--------+------------+---------+----------+
| emp_id | event_day  | in_time | out_time |
+--------+------------+---------+----------+
| 1      | 2020-11-28 | 4       | 32       |
| 1      | 2020-11-28 | 55      | 200      |
| 1      | 2020-12-03 | 1       | 42       |
| 2      | 2020-11-28 | 3       | 33       |
| 2      | 2020-12-09 | 47      | 74       |
+--------+------------+---------+----------+
Output: 
+------------+--------+------------+
| day        | emp_id | total_time |
+------------+--------+------------+
| 2020-11-28 | 1      | 173        |
| 2020-11-28 | 2      | 30         |
| 2020-12-03 | 1      | 41         |
| 2020-12-09 | 2      | 27         |
+------------+--------+------------+
Explanation: 
Employee 1 has three events: two on day 2020-11-28 with a total of (32 - 4) + (200 - 55) = 173, and one on day 2020-12-03 with a total of (42 - 1) = 41.
Employee 2 has two events: one on day 2020-11-28 with a total of (33 - 3) = 30, and one on day 2020-12-09 with a total of (74 - 47) = 27.

Solutioin :
# Write your MySQL query statement below

select 
    event_day as day ,
    emp_id ,
    sum(out_time - in_time) as total_time 
from Employees 
group by emp_id , event_day

--------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------
20.



--------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------
21. 



--------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------
22. https://leetcode.com/problems/project-employees-i/description/

Write an SQL query that reports the average experience years of all the employees for each project, rounded to 2 digits.

Return the result table in any order.

The query result format is in the following example.

Example 1:

Input: 
Project table:
+-------------+-------------+
| project_id  | employee_id |
+-------------+-------------+
| 1           | 1           |
| 1           | 2           |
| 1           | 3           |
| 2           | 1           |
| 2           | 4           |
+-------------+-------------+
Employee table:
+-------------+--------+------------------+
| employee_id | name   | experience_years |
+-------------+--------+------------------+
| 1           | Khaled | 3                |
| 2           | Ali    | 2                |
| 3           | John   | 1                |
| 4           | Doe    | 2                |
+-------------+--------+------------------+
Output: 
+-------------+---------------+
| project_id  | average_years |
+-------------+---------------+
| 1           | 2.00          |
| 2           | 2.50          |
+-------------+---------------+
Explanation: The average experience years for the first project is (3 + 2 + 1) / 3 = 2.00 and for the second project is (3 + 2) / 2 = 2.50

Solution : 

# Write your MySQL query statement below

select project_id , round(avg(e.experience_years) , 2) as average_years 
from Project as p
left join Employee as e
on p.employee_id = e.employee_id
group by project_id

--------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------
23. https://leetcode.com/problems/confirmation-rate/description/



--------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------
24.



--------------------------------------------------------------------------------------------------------------------
--------------------------------------------------------------------------------------------------------------------
25.











