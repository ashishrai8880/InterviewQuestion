
*********************************************************** DSA ****************************************************************************************

1. Find the largest possible number that can be formed by using digits of array which can be divisible by 3. 
For Example : [7,6,4,4,4,2,1] . So largest can be 764442 this number is divisible by 3. 

Brute Force : Find all subset of array and then find is this divisible by 3 or not . If yes then store in some variable . 

Optimized Way : If Sum of all element in a number is divisible by 3 then that number will also divisible by 3 . Like 7 6 4 4 4 2 = 27 divisible by 3. 
Approach : Step 1 : Sort the array , and find the sum . 
           Step 2 : Now the sum can have only two remainder either 1 or 2 . If it is 1 , then need to remove smallest element that have remaider 1 when divide by 3 . 
                    Similarily when remainder is 2 , then need to remove/subtract that number which has remainder 2 when divide by 3. 
           Step 3 : Take two array mod1 and mod2 . These array will store all the element which have remainder 1 and 2 respectively . 
           Step 4 : If remainder is 1 Now there can be two cases : If we have mod1 array length greater than 1  , it means we have something to remove / subtract from sum . 
                    Case 2 : If we have mod1 array as empty , means there is no element to delete , then what to do !!!! . So now we have to remove 2 elements from 
                    mod2 array . Obviously , thoda soch , dimag pe zor daal . Remainder 1 ko counter krne k liye two 2 remainder subtract krna padega . agar sirf 1 element 
                    subtract krega , to fir remainder 2 ho jayega . to 1 or krna padega . 




function largestDivisibleBy3(arr) {
  arr.sort((a, b) => b - a);

  let sum = arr.reduce((a, b) => a + b, 0);
  let mod = sum % 3;

  if (mod !== 0) {
    let mod1 = [];
    let mod2 = [];

    for (let i = arr.length - 1; i >= 0; i--) {
      if (arr[i] % 3 === 1) mod1.push(i);
      else if (arr[i] % 3 === 2) mod2.push(i);
    }

    if (mod === 1) {
      if (mod1.length >= 1) {
        arr.splice(mod1[0], 1);
      } else if (mod2.length >= 2) {
        arr.splice(mod2[0], 1);
        arr.splice(mod2[1] - 1, 1);
      } else {
        return "0";
      }
    }

    if (mod === 2) {
      if (mod2.length >= 1) {
        arr.splice(mod2[0], 1);
      } else if (mod1.length >= 2) {
        arr.splice(mod1[0], 1);
        arr.splice(mod1[1] - 1, 1);
      } else {
        return "0";
      }
    }
  }

  return arr.length ? arr.join("") : "0";
}

// Example
console.log(largestDivisibleBy3([7,6,4,4,4,2,1]));
One more example [2,2,2,2,2] . agar na samajh aaya ho to , isko dry run krne ka . 


2. Similar question over leetcode also there , Take reference from there . Leetcode : https://leetcode.com/problems/greatest-sum-divisible-by-three/description/

/**
 * @param {number[]} nums
 * @return {number}
 */
var maxSumDivThree = function(nums) {
    
    nums.sort((a,b)=>b-a);

    let sum = nums.reduce( (a,b) => a+b );
    let mod = sum%3 ;

    let mod1 = [];
    let mod2 = [];

    nums.reverse().forEach((e , i)=>{
        if(e % 3 == 1){
            mod1.push(e);
        }
        if(e % 3 ==2){
            mod2.push(e);
        }
    })

    if(mod == 0) return sum ;

    let ans = 0 ;

    if(mod == 1){
        let fSum = mod1.length >=1 ?  sum - mod1[0] : 0
        let sSum = mod2.length >=2 ?  sum - mod2[0] - mod2[1] : 0
        ans = Math.max(ans , fSum , sSum)
    }

    if(mod == 2){
        
        let fSum = mod2.length >=1 ?  sum - mod2[0] : 0
        let sSum = mod1.length >=2 ?  sum - mod1[0] - mod1[1] : 0
        ans = Math.max(ans , fSum , sSum)
    }

    return ans ;
};



3. Question 3 . Find the first non repeating number from array . 
Brute Force : Take two loop , and then find which is first element , time complexity : O(n^2) . 
Optimized Approach : Take hashmap , first store all occurence , and then again traverse loop , to check which is first element which has occurence 1 . 

function firstNonRepeating(arr , n)
{
    const m = new Map();
    for (var i = 0; i < n; i++) {
        if (m.has(arr[i])) {
            m.set(arr[i], m.get(arr[i]) + 1);
        }
        else {
            m.set(arr[i], 1);
        }
    }
    
    for (var i = 0; i < n; i++)
        if (m.get(arr[i]) == 1)
            return arr[i];
    return -1;
}

Time Complexity: O(2n), Traverse over the array to map the frequency and again traverse over the array to check for frequency.
Auxiliary Space: O(n), Create a hash table for storing frequency . 

Interviewer : Can you do this in just 1 loop . In Just O(N) TC . Interesting . 

Approach : Take one map , and one queue . store occurence in map and at the same time , store element in queue which occured for first time . At last 
            at the same time , keep removing element from queue which has occurence more than 1 . 

function firstNonRepeatingOnePass(arr) {
  const freq = new Map();
  const queue = [];

  for (let num of arr) {
    freq.set(num, (freq.get(num) || 0) + 1);

    if (freq.get(num) === 1) {
      queue.push(num);
    }

    // Remove elements from front that are no longer non-repeating
    while (queue.length && freq.get(queue[0]) > 1) {
      queue.shift();
    }
  }

  return queue.length ? queue[0] : -1;
}



******************************************************************* Database Question SQL Queries *****************************************************************

1. person: id, name,  city_id
city: id, name, is_metro
Unique list of city names with no person

SELECT DISTINCT c.name
FROM city c
LEFT JOIN person p
    ON c.id = p.city_id
WHERE p.city_id IS NULL;

Second Solution :  Select distinct(name) from city 
                    where id not in (
                      select city_id from person 
                      where city_id is not null
                    )

2. find number of persons per city name where total number of persons is more than 30 and city is metro then sorted by city name in descending order

SELECT 
    c.name AS city_name,
    COUNT(p.id) AS total_persons
FROM city c
JOIN person p
    ON p.city_id = c.id
WHERE c.is_metro = true
GROUP BY c.name
HAVING COUNT(p.id) > 30
ORDER BY c.name DESC;


Logic : Interview me maine c.is_metro ko having k aage likha tha jo ki galat hai . ye aggregate k andar nahi aata , isliye isko WHERE k andar likhna chahiye . 
        WHERE clause pehle use krte hai group_by k . aaisa bhi nahi hai ki , bilkul hi use nahi karna jaha pe group_by hai . 


3. If ORDER_BY clause put before group_by or having will that work or  not ??
Ans : No, it will NOT work. In SQL, clauses must follow a fixed syntax order. This will throw a syntax error in all standard SQL databases.
  Correct syntax order.
    SELECT
    FROM
    WHERE
    GROUP BY
    HAVING
    ORDER BY


  Logical execution order (interview bonus)
Even more important: SQL runs in this logical order, not the written order:

FROM -> JOIN -> WHERE -> GROUP BY -> HAVING -> SELECT -> ORDER BY



*************************************************************** System Design ****************************************************************************

1. There is one nodejs application and that application goes down in every 2 hours due to memory issues . How would you find where is the bug , how you solve 
    this problem , how to debug this . 

ðŸ“ Step 1: Understand the problem
Key info:
App crashes every 2 hours â†’ reproducible pattern
Reason: memory issue
Node.js â†’ uses V8 garbage collection, single-threaded

Interviewers expect you to ask clarifying questions first:
â€œIs this crash happening in production or development?â€
â€œDo we have logs or monitoring set up?â€
â€œIs the memory gradually increasing, or is there a sudden spike?â€

Step 2: Check memory usage over time
Monitor memory:
node --inspect app.js

Or use tools like:
pm2: pm2 monit
top / htop / docker stats
Node.js built-in:
console.log(process.memoryUsage());

Look for:
Heap size (heapUsed / heapTotal)
RSS (total memory used by the process)

Step 3: Identify memory leaks
Memory leaks are the most common cause of Node.js crashes.
Use Chrome DevTools for Node:
node --inspect app.js

Open chrome://inspect in Chrome
Take heap snapshots every 30â€“60 minutes
Compare snapshots to see which objects keep increasing â†’ memory leak
Use Node.js modules:
heapdump â†’ generate heap snapshots programmatically
memwatch-next â†’ monitor memory leaks in real-time
clinic â†’ clinic doctor / clinic flame for CPU & memory profiling


Start
  |
  v
[1. Confirm Problem]
  - App crashes every 2 hours
  - Check logs, error messages
  |
  v
[2. Monitor Memory]
  - process.memoryUsage()
  - PM2 / top / htop
  - Check heapUsed / RSS
  |
  v
[3. Identify Memory Leak?]
  |
  +--> No --> [Check sudden spikes, optimize code, exit]
  |
  v
  Yes
  |
  v
[4. Take Heap Snapshots]
  - Chrome DevTools: node --inspect
  - heapdump module
  - memwatch-next
  |
  v
[5. Analyze Growing Objects]
  - Look for globals, arrays, caches
  - Check event listeners / DB connections
  |
  v
[6. Fix Memory Leak]
  - Limit cache size
  - Close DB/file handles
  - Use streams for large data
  - Remove unused globals
  |
  v
[7. Stress Test Locally]
  - Simulate production load
  - Monitor memory growth
  |
  v
[8. Deploy & Monitor]
  - PM2 max-memory-restart
  - Alerts for high memory
  - Continuous monitoring
  |
  v
End





























