
***************************1. How to handle event loop to not get blocked ?

üîÅ Why the Node.js event loop gets blocked

Node.js runs JavaScript on a single thread.
If that thread is busy doing CPU-heavy or synchronous work, the event loop can‚Äôt process:

incoming requests

timers

I/O callbacks

‚û°Ô∏è Result: your app ‚Äúfreezes‚Äù or becomes slow.

‚ùå Common things that block the event loop
1. Synchronous operations
fs.readFileSync('big.txt'); // ‚ùå blocks

2. Heavy CPU calculations
while (true) {} // ‚ùå blocks everything

3. Large JSON parsing
JSON.parse(hugeString); // ‚ùå can block

4. Bad async patterns
for (let i = 0; i < 1e9; i++) {
  await doSomething(); // ‚ùå serial + slow
}

‚úÖ How to prevent event loop blocking

1Ô∏è‚É£ Use async, non-blocking APIs

Always prefer async versions.

// ‚úÖ Non-blocking
fs.readFile('big.txt', (err, data) => {});

or with promises:

await fs.promises.readFile('big.txt');

2Ô∏è‚É£ Offload CPU-heavy work
‚úî Use Worker Threads (best for CPU tasks)
const { Worker } = require('worker_threads');

new Worker('./worker.js', {
  workerData: bigData
});

‚úî Good for:
encryption
image processing
data transformation

3Ô∏è‚É£ Use child processes (for isolation)
const { fork } = require('child_process');
fork('heavyTask.js');

‚úî Useful for:
background jobs
long-running tasks

4Ô∏è‚É£ Break large tasks into chunks

Yield back to the event loop.

function processChunk(items) {
  const chunk = items.splice(0, 1000);

  chunk.forEach(doWork);

  if (items.length) {
    setImmediate(() => processChunk(items)); // ‚úÖ yields
  }
}

6Ô∏è‚É£ Use streams for large data
fs.createReadStream('big.txt')
  .pipe(fs.createWriteStream('copy.txt'));

‚úî Prevents loading everything into memory.

‚ö†Ô∏è Golden rule
If it takes more than ~10‚Äì20ms of CPU time, don‚Äôt run it on the main thread.


********************************* 2. What is worker thread ***********************************************
A worker thread is:
A separate JavaScript thread with its own event loop, own call stack, and own V8 instance

When you create a worker thread:
It runs in parallel to the main thread
It does not block the main event loop
It can execute CPU-heavy code safely

Think of it like this:

Main Thread (Event Loop)
 ‚îú‚îÄ‚îÄ handles HTTP requests
 ‚îú‚îÄ‚îÄ timers
 ‚îú‚îÄ‚îÄ async I/O
 ‚îî‚îÄ‚îÄ delegates heavy work

Worker Thread
 ‚îî‚îÄ‚îÄ runs heavy CPU logic

2Ô∏è‚É£ Does a worker thread execute code in parallel with the event loop?
‚úÖ YES ‚Äî truly in parallel

This is real parallelism, not async trickery.

If you have:
1 main thread
1 worker thread

And your CPU has at least 2 cores:
‚û°Ô∏è both run at the same time.

CPU Core 1 ‚Üí Main Event Loop
CPU Core 2 ‚Üí Worker Thread

So while the worker is crunching numbers:
the main thread keeps serving requests
timers still fire
sockets still work

3Ô∏è‚É£ Why async/await alone is NOT enough

This is a common misunderstanding.

await heavyComputation(); // ‚ùå still blocks

Why?
async/await only helps with I/O
CPU work still runs on the same thread

So:
async ‚â† parallel
worker threads = parallel

4Ô∏è‚É£ How a worker thread actually works (internally)

When you do:
new Worker('./worker.js')

Node:
Spawns a new thread
Starts a new JS runtime
Loads worker.js
Runs it independently

Communication happens via:
postMessage()
SharedArrayBuffer (advanced)


5Ô∏è‚É£ Simple example (image processing)
Main thread
const { Worker } = require('worker_threads');

function resizeImage(imageBuffer) {
  return new Promise((resolve, reject) => {
    const worker = new Worker('./imageWorker.js', {
      workerData: imageBuffer
    });

    worker.on('message', resolve);
    worker.on('error', reject);
  });
}

#Worker thread
const { workerData, parentPort } = require('worker_threads');
const result = heavyImageProcessing(workerData);
parentPort.postMessage(result);


üìå While heavyImageProcessing() runs:
event loop stays free
requests continue
app stays responsive

6Ô∏è‚É£ Are worker threads the same as child processes?
Feature	          Worker Thread	                Child Process
Memory	          Shared (optional)	            Separate
Startup cost	    Low	                          High
Communication	    Fast	                        Slower (IPC)
Best for	        CPU tasks	                    Isolation

7Ô∏è‚É£ How many worker threads should you use?

Rule of thumb:
maxWorkers = number_of_CPU_cores - 1

Why?
Leave one core for the event loop
Too many workers = context switching overhead
You can get CPU count:

const os = require('os');
os.cpus().length;

8Ô∏è‚É£ When should you NOT use worker threads?

‚ùå Don‚Äôt use workers for:

database calls
HTTP requests
file I/O

Those are already async & non-blocking.

9Ô∏è‚É£ Mental model (remember this üëá)

Node.js is single-threaded for I/O, but multi-threaded for CPU if you allow it
Workers are how you ‚Äúunlock‚Äù multiple cores.


***************************************** Child Process ****************************************************
A child process in Node.js is a way for your app to run another program in the background without blocking itself.

First, a tiny idea: what is a ‚Äúprocess‚Äù?
When you run a program on your computer, the computer starts a process.

Example:
You open Chrome ‚Üí Chrome runs as a process
You run node app.js ‚Üí Node.js runs as a process

So a process = a running program

What is Node.js doing?

---> When you start a Node.js app:

node app.js

Node.js runs your code in one main process.
This main process:
Handles requests
Runs your JavaScript code
Uses one CPU core by default

A child process is simply:
A new program started by your Node.js program

Very simple mental model üß†
Main Node App (Parent)
        |
        |---- Child Process (extra helper)
        |---- Child Process (another helper)

Each child:
Runs separately
Can do heavy work
Won‚Äôt block the main app

Types of child processes (just names for now)
Node.js gives you a few ways to create them:
exec() ‚Üí run simple commands
spawn() ‚Üí stream data (better for large output)
fork() ‚Üí run another Node.js file

1Ô∏è‚É£ exec ‚Äì ‚ÄúRun a command and give me the result‚Äù
What it‚Äôs for
Use exec when:
The command is small
You want the final output as a string

Real-life analogy

üëâ ‚ÄúRun this command and tell me what it prints.‚Äù

Simple example
const { exec } = require("child_process");

exec("node -v", (error, stdout, stderr) => {
  console.log("Node version is:", stdout);
});

What happens step-by-step

Your Node app starts
It creates a child process
That process runs node -v
The entire output is returned at once

Important thing to know ‚ö†Ô∏è
Output is stored in memory
Not good for big output

‚úîÔ∏è Good for:
Checking versions
Running small commands

2Ô∏è‚É£ spawn ‚Äì ‚ÄúRun a command and show output little by little‚Äù
What it‚Äôs for

Use spawn when:
Output is large
You want data as it happens

Real-life analogy

üëâ ‚ÄúRun this command and keep talking while it runs.‚Äù

Simple example
const { spawn } = require("child_process");

const child = spawn("node", ["-v"]);

child.stdout.on("data", (data) => {
  console.log("Output:", data.toString());
});

What happens step-by-step
Node creates a child process
The command starts running
Output comes in chunks
You receive data piece by piece

*******3Ô∏è‚É£ fork ‚Äì ‚ÄúRun another Node.js file‚Äù
What it‚Äôs for
Use fork when:
You want to run another Node.js script
You want to send messages back and forth

Real-life analogy

üëâ ‚ÄúRun this Node.js file and let‚Äôs talk to each other.‚Äù

Simple example
parent.js
const { fork } = require("child_process");

const child = fork("child.js");

child.on("message", (msg) => {
  console.log("From child:", msg);
});

child.send("Hello child!");

child.js
process.on("message", (msg) => {
  console.log("From parent:", msg);
  process.send("Hello parent!");
});

What happens
Parent starts
Parent forks another Node.js file
They can talk using messages
Heavy work can run in the child

üß† Beginner rule of thumb
Small command ‚Üí exec
Big / long task ‚Üí spawn
Another Node.js file ‚Üí fork

One-line summary

exec waits for everything, spawn listens while it runs, and fork talks to another Node.js program.

Must Read Article :  https://dev.to/wallacefreitas/understanding-worker-threads-and-child-processes-52nj

***************** Difference between child process and worker threads ****************************************
Choosing Between Worker Threads and Child Processes

Feature	                          Worker Threads	                              Child Processes
Memory Sharing	                  Supported via SharedArrayBuffer	              Not supported
Task Isolation	                  Shared environment, less isolated	            Fully isolated
Use Case	                        CPU-intensive tasks in JavaScript	            System-level tasks or external code
Overhead	                        Lower (same process)	                        Higher (separate processes)
Communication	                    Via message passing, faster	                  Via IPC, slower
Supported Languages	              JavaScript/Node.js only	                      Any scripting or system-level language
Startup Time	                    Faster	                                      Slower
Error Containment	                Less contained, can crash the process	        Fully contained, isolated failures






