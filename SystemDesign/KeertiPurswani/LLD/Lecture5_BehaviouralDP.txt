
********************************************** SingleTon Design Pattern *************************************************
1Ô∏è‚É£ What is the Singleton Pattern?

Singleton = exactly ONE instance of a class for the entire application.

Why use it?
      Shared resources (DB connection, logger, config manager)
      Global state (but use sparingly üëÄ)
      Avoid expensive object creation multiple times

Core rules
      Constructor is private
      Class controls its own instance
      Public method to access that instance

In Java 
2Ô∏è‚É£ Basic Singleton (Single-threaded idea)

class Singleton {
    private static Singleton instance;

    private Singleton() {} // private constructor

    public static Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}

‚ùå Problem:
In multithreading, two threads can enter getInstance() at the same time and create two instances.

3Ô∏è‚É£ Why Multithreading Breaks Singleton

Imagine this:
Thread A ‚Üí instance == null ‚úî
Thread B ‚Üí instance == null ‚úî
Thread A ‚Üí new Singleton()
Thread B ‚Üí new Singleton()
Boom üí• two objects. Singleton violated.

4Ô∏è‚É£ How to Make Singleton Thread-Safe in Java

‚úÖ Option 1: Synchronized Method (Simple, but slow)
class Singleton {
    private static Singleton instance;

    private Singleton() {}

    public static synchronized Singleton getInstance() {  // basically synchronised = lock()
        // lock()
        if (instance == null) {
            instance = new Singleton();
        }
        // unlock()
        return instance;
    }
}

‚úî Thread-safe
‚ùå Every call is synchronized ‚Üí performance hit

‚úÖ Option 2: Double-Checked Locking (Best balance)

class Singleton {
    private static volatile Singleton instance;

    private Singleton() {}

    public static Singleton getInstance() {
        if (instance == null) {               // 1st check
            // lock()
            synchronized (Singleton.class) {    // lock
                if (instance == null) {       // 2nd check
                    instance = new Singleton();
                }
            } 
            // unlock()
        }
        return instance;
    }
}

Why this works:
        volatile prevents instruction reordering
        Synchronization happens only once
        Fast after initialization
        ‚úî Thread-safe
        ‚úî High performance
        ‚úÖ Most commonly used


5Ô∏è‚É£ Lazy Initialization vs Eager Initialization
‚úÖ : Eager Initialization (Thread-safe by default)
class Singleton {
    private static final Singleton INSTANCE = new Singleton();

    private Singleton() {}

    public static Singleton getInstance() {
        return INSTANCE;
    }
}

In Eager Initialisation : Object/Instance of class is created inside class only while variable declaration and 
initialisation . Object is created at class loading time .

Pros
  Thread-safe
  Simple

Cons
  Object created even if unused
  Not ideal for expensive resources

‚úÖ : Lazy Initialization : As we saw above , all are lazy initialisation . here object will create only when getInstance()
method will get callled somewhere in client code when it is needed . Otherwise there will not be any object of that class .

Pros
    Saves memory
    Delays heavy object creation

Cons
    Needs synchronization in multithreading
    More complex


------------- In Typescript
class Singleton {
    private static instance: Singleton;

    private constructor() {}

    static getInstance(): Singleton {
        if (!Singleton.instance) {
            Singleton.instance = new Singleton();
        }
        return Singleton.instance;
    }
}



*********************************************** Behavioural Design Pattern ***********************************************
*********************************************** 1. Observer Design Pattern *************************************************
Medium Link =>> https://devcookies.medium.com/observer-design-pattern-a-complete-guide-with-examples-ec40648749ff

The Observer Design Pattern is one of the most commonly used behavioral design patterns in software development. It is 
particularly useful when you want to establish a one-to-many relationship between objects. This allows an object (known as
the subject) to notify other objects (known as observers) when there is a change in its state. The Observer pattern is 
widely used in event-driven programming, GUIs, and even in messaging systems like Kafka.

Why Use the Observer Pattern?
The Observer Pattern helps with:
         - Decoupling: It decouples the subject from its observers, meaning the subject doesn‚Äôt need to know who or how many 
observers there are.
         - Event handling: Whenever the state of the subject changes, all dependent observers are notified automatically.

        - Dynamic relationships: New observers can be added or removed at runtime without affecting the subject.

There are three main components:
    Subject: The object that holds the state and notifies the observers.
    Observer: Objects that listen for state changes in the subject.
    ConcreteSubject: The class that implements the Subject interface.
    ConcreteObserver: The class that implements the Observer interface and responds to changes in the subject.


Real-World Example
Imagine you‚Äôre working on a weather application. The weather station (Subject) collects data such as temperature and 
humidity. You have multiple displays (Observers) that should automatically update whenever the weather data changes. Instead
of having the displays continually check for new data, they can simply be notified by the weather station when there‚Äôs a 
change.

### Implementation 

// Observer interface
interface Observer {
    update(order: Order): void;
}

// Customer observer
class Customer implements Observer {
    private name: string;

    constructor(name: string) {
        this.name = name;
    }

    update(order: Order): void {
        console.log(
            `Hello, ${this.name}! Order #${order.getId()} is now ${order.getStatus()}.`
        );
    }
}

// Restaurant observer
class Restaurant implements Observer {
    private restaurantName: string;

    constructor(name: string) {
        this.restaurantName = name;
    }

    update(order: Order): void {
        console.log(
            `Restaurant ${this.restaurantName}: Order #${order.getId()} is now ${order.getStatus()}.`
        );
    }
}

// Delivery driver observer
class DeliveryDriver implements Observer {
    private driverName: string;

    constructor(name: string) {
        this.driverName = name;
    }

    update(order: Order): void {
        console.log(
            `Driver ${this.driverName}: Order #${order.getId()} is now ${order.getStatus()}.`
        );
    }
}

// Call center observer
class CallCenter implements Observer {
    update(order: Order): void {
        console.log(
            `Call center: Order #${order.getId()} is now ${order.getStatus()}.`
        );
    }
}

// Subject (Order)
class Order {
    private id: number;
    private status: string;
    private observers: Observer[] = [];

    constructor(id: number) {
        this.id = id;
        this.status = "Order Placed";
    }

    getId(): number {
        return this.id;
    }

    getStatus(): string {
        return this.status;
    }

    setStatus(newStatus: string): void {
        this.status = newStatus;
        this.notifyObservers();
    }

    attach(observer: Observer): void {
        this.observers.push(observer);
    }

    detach(observer: Observer): void {
        this.observers = this.observers.filter(o => o !== observer);
    }

    private notifyObservers(): void {
        for (const observer of this.observers) {
            observer.update(this);
        }
    }
}

// Main execution
const order1 = new Order(123);

// Create observers
const customer1 = new Customer("Customer 1");
const restaurant1 = new Restaurant("Rest 1");
const driver1 = new DeliveryDriver("Driver 1");
const callCenter = new CallCenter();

// Attach observers
order1.attach(customer1);
order1.attach(restaurant1);
order1.attach(driver1);
order1.attach(callCenter);

// Simulate order status updates
order1.setStatus("Out for Delivery");

// Detach an observer
order1.detach(callCenter);

// Simulate more updates
order1.setStatus("Delivered");


*************************************************************************************************************************
********************************************* Command Design Pattern ****************************************************

In real systems, you often have this situation:
      A UI / API / service layer triggers actions
      The actual business logic is elsewhere
      You want to:
            Decouple the request from the execution
            Queue, log, retry, undo, or audit actions
            Avoid massive if/else or switch statements
            Change behavior without changing the caller

-------Without Command (Typical Mess)

function handleAction(action: string) {
    if (action === "CREATE_ORDER") {
        // create order logic
    } else if (action === "CANCEL_ORDER") {
        // cancel order logic
    } else if (action === "REFUND_ORDER") {
        // refund logic
    }
}

‚ùå Tight coupling
‚ùå Hard to extend
‚ùå No easy undo / retry / queue
‚ùå Violates Open‚ÄìClosed Principle

2Ô∏è‚É£ What the Command Pattern Is
      Command Pattern encapsulates a request as an object.

This means:
      Each action = its own command object
      Caller doesn‚Äôt know how it‚Äôs done
      Caller only knows: ‚Äúexecute this command‚Äù

Participants
      Command interface ‚Äì defines execute()
      Concrete Commands ‚Äì actual actions
      Receiver ‚Äì does the real work
      Invoker ‚Äì triggers the command
      Client ‚Äì wires everything together

4Ô∏è‚É£ Step-by-Step TypeScript Implementation

1Ô∏è‚É£ Command Interface
interface Command {
    execute(): Promise<void>;
}

2Ô∏è‚É£ Receiver (Business Logic)
class OrderService {
    async placeOrder(orderId: string) {
        console.log(`Order ${orderId} placed`);
    }

    async cancelOrder(orderId: string) {
        console.log(`Order ${orderId} cancelled`);
    }

    async refundOrder(orderId: string) {
        console.log(`Order ${orderId} refunded`);
    }
}

3Ô∏è‚É£ Concrete Commands
Each command represents one business action.

class PlaceOrderCommand implements Command {
    constructor(
        private orderService: OrderService,
        private orderId: string
    ) {}

    async execute(): Promise<void> {
        await this.orderService.placeOrder(this.orderId);
    }
}

class CancelOrderCommand implements Command {
    constructor(
        private orderService: OrderService,
        private orderId: string
    ) {}

    async execute(): Promise<void> {
        await this.orderService.cancelOrder(this.orderId);
    }
}

class RefundOrderCommand implements Command {
    constructor(
        private orderService: OrderService,
        private orderId: string
    ) {}

    async execute(): Promise<void> {
        await this.orderService.refundOrder(this.orderId);
    }
}

Each command:
      Has one responsibility
      Is easy to test
      Easy to extend

4Ô∏è‚É£ Invoker (API / Controller / Job Runner)
class CommandExecutor {
    async run(command: Command): Promise<void> {
        // Cross-cutting concerns go here
        console.log("Command started");

        await command.execute();

        console.log("Command finished");
    }
}

5Ô∏è‚É£ Client Wiring (API Layer Example)

const orderService = new OrderService();
const executor = new CommandExecutor();

const command = new PlaceOrderCommand(orderService, "ORD-123");

await executor.run(command);


Tomorrow, you add a new command?
üëâ Zero change to executor
üëâ Zero change to existing commands

5Ô∏è‚É£ What Problem Did Command Actually Solve?
‚úÖ Decoupling
      Invoker doesn‚Äôt care what the command does.

‚úÖ Open‚ÄìClosed Principle
      Add new behavior by adding new classes.

‚úÖ Undo / Retry / Queue Support
Because commands are objects:
      Store them
      Serialize them   
      Retry on failure     
      Push to queues

---------------- UML 
@startuml
interface Command {
    +execute()
}

class ConcreteCommand {
    -receiver: Receiver
    +execute()
}

class Receiver {
    +action()
}

class Invoker {
    -command: Command
    +setCommand(Command)
    +invoke()
}

class Client

Client --> ConcreteCommand : creates
ConcreteCommand ..|> Command
ConcreteCommand --> Receiver : calls
Invoker --> Command : invokes
@enduml

+------------------+
|     Command      |
|------------------|
| + execute()      |
+------------------+
          ^
          |
+-------------------------+
|   ConcreteCommand       |
|-------------------------|
| - receiver: Receiver   |
| + execute()             |
+-------------------------+
          |
          v
+------------------+
|    Receiver      |
|------------------|
| + action()       |
+------------------+

+------------------+
|     Invoker      |
|------------------|
| - command        |
| + invoke()       |
+------------------+

Client ---> ConcreteCommand
Invoker ---> Command


-------------------------------- Example 2 ------------------------------

// Receiver: RideService
class RideService {
    requestRide(passenger: string, srcLoc: string, destLoc: string): void {
        console.log(
            `Requesting a ride for passenger: ${passenger} from ${srcLoc} to ${destLoc}`
        );
        // Additional ride request processing logic here
    }

    cancelRide(passenger: string): void {
        console.log(`Canceling the ride for passenger: ${passenger}`);
        // Additional cancellation logic here
    }
}

// Command interface
interface Command {
    execute(): void;
}

// Concrete Command: RideRequestCommand
class RideRequestCommand implements Command {
    constructor(
        private receiver: RideService,
        private passenger: string,
        private srcLoc: string,
        private destLoc: string
    ) {}

    execute(): void {
        this.receiver.requestRide(this.passenger, this.srcLoc, this.destLoc);
    }
}

// Concrete Command: CancelRideCommand
class CancelRideCommand implements Command {
    constructor(
        private receiver: RideService,
        private passenger: string
    ) {}

    execute(): void {
        this.receiver.cancelRide(this.passenger);
    }
}

// Invoker: RideRequestInvoker
class RideRequestInvoker {
    processRequest(command: Command): void {
        command.execute();
    }
}

// Client code (equivalent to main method)
const rideService = new RideService();
const rideRequestInvoker = new RideRequestInvoker();

const request1: Command = new RideRequestCommand(
    rideService,
    "Keerti",
    "Sarjapur",
    "Koramangala"
);

const request2: Command = new RideRequestCommand(
    rideService,
    "Amit",
    "Koramangala",
    "Indiranagar"
);

const cancel1: Command = new CancelRideCommand(
    rideService,
    "Keerti"
);

// Process requests
rideRequestInvoker.processRequest(request1);
rideRequestInvoker.processRequest(request2);
rideRequestInvoker.processRequest(cancel1);



UML 
@startuml
interface Command {
    +execute()
}

class RideRequestCommand {
    -receiver: RideService
    -passenger: String
    -srcLoc: String
    -destLoc: String
    +execute()
}

class CancelRideCommand {
    -receiver: RideService
    -passenger: String
    +execute()
}

class RideService {
    +requestRide(passenger, srcLoc, destLoc)
    +cancelRide(passenger)
}

class RideRequestInvoker {
    +processRequest(command)
}

class Client

Command <|.. RideRequestCommand
Command <|.. CancelRideCommand

RideRequestCommand --> RideService
CancelRideCommand --> RideService

RideRequestInvoker --> Command
Client --> RideRequestCommand
Client --> CancelRideCommand
Client --> RideRequestInvoker
@enduml




            +------------------+
            |     Command      |
            |------------------|
            | + execute()      |
            +------------------+
                 ^        ^
                 |        |
+----------------------+   +----------------------+
| RideRequestCommand   |   | CancelRideCommand    |
|----------------------|   |----------------------|
| - receiver           |   | - receiver           |
| - passenger          |   | - passenger          |
| - srcLoc             |   |                      |
| - destLoc            |   |                      |
| + execute()          |   | + execute()          |
+----------+-----------+   +----------+-----------+
           |                          |
           v                          v
      +-------------------------------+
      |          RideService          |
      |-------------------------------|
      | + requestRide()               |
      | + cancelRide()                |
      +-------------------------------+

+----------------------------+
|   RideRequestInvoker       |
|----------------------------|
| + processRequest(Command) |
+----------------------------+

Client --> Commands
Client --> Invoker
Invoker --> Command


























