
1. OAuth 2.0 
OAuth 2.0 is an authorization framework that lets a third-party app access a userâ€™s resources without sharing the userâ€™s password.
The official standard is maintained by the Internet Engineering Task Force (IETF).

ğŸ”‘ Core Roles in OAuth 2.0

There are 4 main players:
    Resource Owner â†’ The user
    Client â†’ The application requesting access
    Authorization Server â†’ Issues tokens
    Resource Server â†’ Hosts the protected data (API)

ğŸ”„ High-Level OAuth 2.0 Flow (Authorization Code Flow) - This is the most common and secure flow.

Step 1ï¸âƒ£ â€“ User Clicks â€œLogin with Xâ€ - 
The client app redirects the user to the Authorization Server with: [ client_id , redirect_uri , scope , response_type=code ]
Example:
```
GET /authorize?
  client_id=abc123
  &redirect_uri=https://app.com/callback
  &response_type=code
  &scope=profile email
```

Step 2ï¸âƒ£ â€“ User Authenticates - The user logs in on the Authorization Server. 
Important:
      ğŸ‘‰ The password is entered ONLY on the Authorization Server.
      ğŸ‘‰ The client app never sees the password.

Step 3ï¸âƒ£ â€“ Authorization Code Returned - If the user approves access, the Authorization Server redirects back:
```
https://app.com/callback?code=AUTH_CODE
```
This authorization code is temporary and short-lived.

Step 4ï¸âƒ£ â€“ Client Exchanges Code for Access Token - The client makes a backend POST request:
```
POST /token
  grant_type=authorization_code
  code=AUTH_CODE
  client_secret=SECRET
```
The server responds with:
```
{
  access_token: "xyz",
  refresh_token: "abc",
  expires_in: 3600
}
```

Step 5ï¸âƒ£ â€“ Client Calls API - The client now calls the Resource Server: 
```
GET /userinfo
Authorization: Bearer ACCESS_TOKEN
```

OAuth -> Authorised Framework that allows 3rd Party apps to access limited resources for specific period of time on a server without exposing credentials . 

------------------------------------------------------------------------------------------------------

What if jwt token is stolen ?
1. We can use concept of refresh token . And main token time to live would be 5-15 minutes only so that destructive time for hacker would be less . 
Flow - 

In Login API server will send accessToken and refreshToken to client 
Client will store accessToken in localStorage and refreshToken will be set to cookie (httpOnly accesss) in client . 
Now every time client request for any API , it will use accessToekn for authentication . After 10 minutes or few time , accessToken will get expired . 
Now client will get 401 , now client will hit /refreshToken API , now this API will give again accessToken . 
Now client again store this accessTokenn in localStorage and hit same API to server . Now server will give response . 

====> Rotation of Refresh Token 
What if refresh token which has long time to expiry get stolen . 
For this , in every /refresh-token API hit , generate refreshToken and accessToken both . set refreshToken inside cookie and accessToken in localStorage . 

ğŸª 1ï¸âƒ£ Who Stores Cookies? Server or Client?
ğŸ‘‰ Cookies are stored in the browser (client).
Butâ€¦
ğŸ‘‰ They are usually created by the server.
Hereâ€™s how it works:
When user logs in, server sends this in HTTP response:
```
Set-Cookie: refreshToken=abc123;
 HttpOnly;
 Secure;
 SameSite=Strict;
 Path=/;
```
Browser receives this header and:
Stores the cookie
Attaches it automatically to future requests

ğŸ” 2ï¸âƒ£ What Is HttpOnly?
When a cookie has: HttpOnly
It means:
âŒ JavaScript cannot read or modify this cookie
âœ… Only the browser can send it in HTTP requests

ğŸ§  Why Was HttpOnly Created?
To prevent XSS attacks from stealing authentication tokens.


























