
1. Layers : Transport Layer and Application Layer . Two Main Layer . 

Think of OSI as 7 layers of responsibility that data passes through when one computer talks to another.

ðŸ‘‰ As a backend developer, you mainly live in:

Layer 7 â€“ Application

Layer 4 â€“ Transport

Other layers exist, but you mostly just benefit from them.

Layer	        Name	            Should you care?
7	            Application	      âœ… YES (most important)
6	            Presentation	    âš ï¸ Somewhat
5	            Session	          âš ï¸ Rarely
4	            Transport	        âœ… YES (very important)
3	            Network	          âŒ Mostly abstracted
2	            Data Link	        âŒ Ignore
1	            Physical	        âŒ Ignore


Layer 7 â€“ Application Layer (MOST IMPORTANT FOR YOU)
What it actually means

This is not your Node.js app code itself.
Itâ€™s the protocols your app uses to communicate.

Examples you already use daily
HTTP / HTTPS , REST APIs , GraphQL , WebSockets , gRPC , SMTP (emails)

When you write:
app.get("/users", (req, res) => { ... })

ðŸ‘‰ You are working entirely at the Application layer.

What Application Layer is responsible for
Request/response format
Headers
Methods (GET, POST, PUT, DELETE)
Status codes (200, 404, 500)
Authentication (JWT, OAuth tokens)
Cookies
Payload structure (JSON, XML)

System Design perspective (VERY IMPORTANT)

When interviewers talk about:
API design
REST vs GraphQL
Idempotency
Rate limiting
Caching (HTTP cache headers)
Versioning APIs
Authentication & Authorization

ðŸ‘‰ They are talking about the Application Layer

Layer 4 â€“ Transport Layer (SECOND MOST IMPORTANT)
This layer decides how data moves reliably (or fast) between client and server.

Main protocols
TCP âœ…
UDP âš ï¸

TCP (You use this MOST of the time)
What TCP gives you
Reliable delivery
Guaranteed order
Retries if packets are lost
Connection-based
When Node.js uses TCP
HTTP / HTTPS
REST APIs
GraphQL
Database connections (Postgres, MongoDB)

ðŸ‘‰ 99% of backend APIs run on TCP

TCP concepts you SHOULD know (as a backend dev)
1. Connection
TCP establishes a connection before sending data.
Why it matters:
Each open connection consumes server resources
Leads to connection pooling
Impacts scalability

2. Latency & Throughput
TCP is reliable â†’ slightly slower
Retransmissions increase latency
System design impact:
High latency APIs
Slow mobile networks
Retry storms

3. Keep-Alive
Keeps TCP connection open for reuse.
Why you care:
Improves performance
Reduces handshake cost
Node.js example:
http.Agent({ keepAlive: true })

4. Backpressure
If client is slow, TCP slows sending.
Why you care:
Node.js streams
Prevents memory overload

**************UDP (Less common, but know WHY)

UDP is:
Fast
No guarantee
No retries
No ordering

Used for:
Video streaming
Gaming
Live metrics

DNS
ðŸ‘‰ Backend APIs rarely use UDP, but:
gRPC streaming
Real-time systems
may discuss it in system design.

=========> How Application & Transport Layers Work Together
Example: API request flow
Client sends HTTP request (Application Layer)
HTTP uses TCP to send data (Transport Layer)
TCP ensures reliable delivery
Server receives request
Node.js processes it
Response goes back same way

********************************* How connection establish in TCP *********************************************
GFG : https://www.geeksforgeeks.org/computer-networks/what-is-transmission-control-protocol-tcp/
Must read above article super good . 

Transmission Control Protocol (TCP) is a connection-oriented protocol for communications that helps in the exchange of 
messages between different devices over a network. It is one of the main protocols of the TCP/IP suite

** TCP establishes a reliable connection between sender and receiver using the three-way handshake (SYN, SYN-ACK, ACK) and
it uses a four-step handshake (FIN, ACK, FIN, ACK) to close connections properly.
** It ensures error-free, in-order delivery of data packets.
** It uses acknowledgments (ACKs) to confirm receipt.
** It prevents data overflow by adjusting the data transmission rate according to the receiverâ€™s buffer size.
** It prevents network congestion using algorithms like Slow Start, Congestion Avoidance, Fast Retransmit, and Fast Recovery.
** TCP header uses checksum to detect corrupted data and requests retransmission if needed.
It is used in applications requiring reliable and ordered data transfer, such as web browsing, email, and remote login.

----------- Features of TCP
1. Segment Numbering: Each byte of data is numbered, and segments carry sequence numbers. Acknowledgment numbers confirm 
successful receipt.
2. Connection-Oriented: Sender and receiver remain connected until data transfer is complete. Data order is preserved.
3. Full Duplex: Data can flow in both directions simultaneously, improving efficiency.
4. Flow Control: Uses a sliding window to prevent the sender from overwhelming the receiver.
5. Error Control: Detects and manages corrupted, lost, duplicate, or out-of-order segments to ensure reliability.
6. Congestion Control: Adjusts the sending rate based on network congestion to avoid overload.



**************************************************** UDP **********************************************************
UDP does NOT establish a connection. It just sends data and hopes it arrives.
UDP does not establish or maintain a session between client and server.
Each packet is sent independently without handshake, state, or delivery guarantees.
This makes UDP faster and suitable for low-latency and real-time systems where occasional packet loss is acceptable.
What â€œConnectionâ€ Means (Important)

In networking, a connection means: Both sides agree to talk . State is maintained (session info) . Reliability guarantees
exist . Setup & teardown steps exist .

How UDP Data Flow Actually Works

Letâ€™s say Client A wants to send data to Server B using UDP.
Step-by-step UDP flow
1ï¸âƒ£ Client creates a UDP socket
// Node.js example
const socket = dgram.createSocket("udp4");

No handshake. No setup with server.

2ï¸âƒ£ Client sends a message
socket.send("hello", 41234, "server-ip");

What happens internally:
OS wraps the message in a UDP packet
Packet contains: Source IP + port , Destination IP + port , Packet is sent immediately

ðŸ‘‰ Server may or may not even exist.

3ï¸âƒ£ Server receives (if itâ€™s listening)
socket.on("message", (msg, rinfo) => {
  console.log(msg.toString());
});

If:
Server is up
Port is open
Network doesnâ€™t drop packet

ðŸ‘‰ Server receives the message.
If not?
âŒ Message is lost forever.

Client â†’ Data â†’ Server . No Connection . 

*********************************************** HTTP ***********************************************************
History of HTTP
Tim Berners-Lee and his team at CERN get credit for inventing the original HTTP and associated technologies. 

-> HTTP version 0.9: This was the first version of HTTP, which was introduced in 1991. 
-> HTTP version 1.0: In 1996, RFC 1945 (Request For Comments) was introduced in HTTP version 1.0. 
-> HTTP version 1.1: In January 1997, RFC 2068 was introduced in HTTP version 1.1. Improvements and updates to the HTTP 
version 1.1 standard were released under RFC 2616 in June 1999. 
-> HTTP version 2.0: The HTTP version 2.0 specification was published as RFC 7540 on May 14, 2015. 
-> HTTP version 3.0: HTTP version 3.0 is based on the previous RFC draft. It is renamed as Hyper-Text Transfer Protocol QUIC
which is a transport layer network protocol developed by Google.

============> HTTP/2: Improved Performance
HTTP/2 is an improved version of HTTP introduced in 2015. It made several changes to make websites load faster:

* Multiplexing: Multiple requests can be sent over one connection at the same time, reducing delays.
* Header Compression: HTTP/2 compresses the data sent in headers to make it smaller and faster.
* Server Push: This allows the server to send additional resources (like images or scripts) to the browser before the 
browser even asks for them.

* ================> HTTP/3: The Latest Version
HTTP/3, released in 2022, builds on HTTP/2 but with a key improvement: it uses the QUIC protocol instead of TCP. QUIC is 
faster and more reliable because it:

* Reduces connection setup time.
* Handles data loss better, especially in poor network conditions.
* Offers better security by integrating encryption directly into the protocol.


**************************************** Encryption in HTTP *********************************************

Symmetric Encryption : In this both side have same key for encryption and decryption . It is more fast and cheaper but less
secure . 

Assymetric Encryption : There is 1 public key which is available to client and one private key which is at server side only .





















